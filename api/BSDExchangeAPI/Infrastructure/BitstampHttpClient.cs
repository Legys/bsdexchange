//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable CS8765 // Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).

namespace BSDExchangeAPI.Infrastructure
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IBitstampHttpClient
    {

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Account balances
        /// </summary>
        /// <remarks>
        /// Return account balances.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<AccountBalancesResponse>> GetAccountBalancesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Account balance for currency
        /// </summary>
        /// <remarks>
        /// Return account balances for currency.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AccountBalancesResponse> GetAccountBalancesForCurrencyAsync(string currency, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unconfirmed bitcoin deposits
        /// </summary>
        /// <remarks>
        /// This API call is cached for 60 seconds. This call will be executed on the account (Sub or Main), to which
        /// <br/>the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DepositAddressResponse> GetUnconfirmedBTCDepositsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Buy instant order
        /// </summary>
        /// <remarks>
        /// Open a buy instant order. By placing an instant order you acknowledge that the execution of your order
        /// <br/>depends on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only buy 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| Maximum market buy amount at the moment is 'amount' 'currency'. Please use limit order instead. | Order amount exceeds the limit amount set for market buy orders. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BuySellOrderResponse> OpenInstantBuyOrderAsync(string market_symbol, BuyInstantOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Buy market order
        /// </summary>
        /// <remarks>
        /// Open a buy market order. By placing a market order you acknowledge that the execution of your order depends
        /// <br/>on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only buy 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| Maximum market buy amount at the moment is 'amount' 'currency'. Please use limit order instead. | Order amount exceeds the limit amount set for market buy orders. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BuySellOrderResponse> OpenMarketBuyOrderAsync(string market_symbol, BuySellMarketOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Buy limit order
        /// </summary>
        /// <remarks>
        /// Open a buy limit order. This call will be executed on the account (Sub or Main), to which the used API key
        /// <br/>is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| Price is more than 20% above market price. | Order price must not exceed 20% of current price. |
        /// <br/>| You need 'order_value' USD to open that order. You have only 'available_fiat' USD available. Check your account balance for details. | Account has less 'available_fiat' than is required to make this order. |
        /// <br/>| Sell if executed price must be higher than buy price. | 'limit_price' must be larger than 'price' parameter. |
        /// <br/>| Both limit_price and daily_order cannot be set. | Only one of those parameters can be set. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BuySellOrderResponse> OpenLimitBuyOrderAsync(string market_symbol, BuySellLimitOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel all orders
        /// </summary>
        /// <remarks>
        /// Cancel all open orders. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CancelAllOrdersResponse> CancelAllOrdersAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel all orders for market
        /// </summary>
        /// <remarks>
        /// Cancel all open orders for a market. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CancelAllOrdersResponse> CancelOrdersForMarketAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel order
        /// </summary>
        /// <remarks>
        /// Cancel an order. This call will be executed on the account (Sub or Main), to which the used API key is
        /// <br/>bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing id POST param. | Id parameter missing. |
        /// <br/>| Invalid id POST param. | Id parameter must be a positive integer. |
        /// <br/>| Invalid client_cancel_id POST param. | client_cancel_id parameter can contain at most 180 characters. |
        /// <br/>| Order not found | Order with that id was not found in orderbook. Order might already be filled or canceled. Please check order status. |
        /// <br/>| Order cancellation failed due to internal error. Please try again. | Please retry cancelling order. |
        /// <br/>| Order cancelattion failed due to trade halt. | You can cancel order after trade halt is lifted. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CancelOrderResponse> CancelOrderAsync(CancelOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crypto transactions
        /// </summary>
        /// <remarks>
        /// Return user's crypto transactions. This call will be executed on the account, to which the used API key is
        /// <br/>bound to. This call is for your main account only.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Limit too large | Max value of limit parameter is 1000. |
        /// <br/>| Invalid limit | Limit parameter should be number from 1 to 1000. |
        /// <br/>| Offset too large | Offset parameter cannot be larger than 200000. |
        /// <br/>| Invalid offset | Offset parameter needs to be a number from 0 to 200000. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CryptoTransactionsResponse> GetCryptoUserTransactionsAsync(CryptoTransactionsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Currencies
        /// </summary>
        /// <remarks>
        /// Returns list of all currencies with basic data.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<CurrencySchema>> GetCurrenciesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Subscribe to earn
        /// </summary>
        /// <remarks>
        /// Subscribe given amount to lending / staking.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                              |
        /// <br/>|---------------|-------------|-------------------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully subscribed to earn.                                                    |
        /// <br/>| 400           | API5001     | Earn request amount too low.                                                        |
        /// <br/>| 400           | API5002     | Earn request amount too high.                                                       |
        /// <br/>| 400           | API5003     | Decimal places in amount exceed maximum allowed.                                    |
        /// <br/>| 400           | API5004     | Operation is unsupported.                                                           |
        /// <br/>| 400           | API5005     | Operation is currently unavailable, please try again later.                         |
        /// <br/>| 400           | API5006     | Required personal information is missing, please reach out to support@bitstamp.net. |
        /// <br/>| 400           | API5007     | Operation is unavailable, please reach out to support@bitstamp.net.                 |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                                              |
        /// <br/>| 403           |             | This feature is not available for your account.                                     |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task EarnSubscribeAsync(EarnSubscriptionSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get earn subscriptions
        /// </summary>
        /// <remarks>
        /// Get earn subscriptions for user.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Returned earn subscriptions                                 |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<EarnSubscriptionsSchema>> EarnSubscriptionsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Manage subscription settings
        /// </summary>
        /// <remarks>
        /// Manage subscription settings (opt in, opt out). Currently only supported for staking.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully update subscription setting.                   |
        /// <br/>| 400           | API5004     | Operation is unsupported.                                   |
        /// <br/>| 400           | API5005     | Operation is currently unavailable, please try again later. |
        /// <br/>| 400           | API5008     | Already opted in.                                           |
        /// <br/>| 400           | API5009     | Not opted in.                                               |
        /// <br/>| 400           | API5010     | Insufficient balance.                                       |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// <br/>| 403           |             | This feature is not available for your account.             |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task EarnSubscriptionsSettingAsync(EarnSubscriptionSettingSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get earn transactions
        /// </summary>
        /// <remarks>
        /// Get earn transaction history.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Returned earn transaction history.                          |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// </remarks>
        /// <param name="currency">Currency</param>
        /// <param name="limit">Limit result to that many events (default: 100; maximum: 1000)</param>
        /// <param name="offset">Skip that many events before returning results (default: 0, maximum: 200000)</param>
        /// <param name="quote_currency">Currency in which value is calculated</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<EarnTransactionSchema>> EarnTransactionsAsync(string currency = null, int? limit = null, int? offset = null, string quote_currency = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unsubscribe from earn
        /// </summary>
        /// <remarks>
        /// Unsubscribe given amount from lending / staking.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully unsubscribed from earn.                        |
        /// <br/>| 400           | API5001     | Earn request amount too low.                                |
        /// <br/>| 400           | API5002     | Earn request amount too high.                               |
        /// <br/>| 400           | API5003     | Decimal places in amount exceed maximum allowed.            |
        /// <br/>| 400           | API5004     | Operation is unsupported.                                   |
        /// <br/>| 400           | API5005     | Operation is currently unavailable, please try again later. |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// <br/>| 400           | API5012     | Staked balance is insufficient.                             |
        /// <br/>| 403           |             | This feature is not available for your account.             |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task EarnUnsubscribeAsync(EarnSubscriptionSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// EUR/USD conversion rate
        /// </summary>
        /// <remarks>
        /// Return EUR/USD conversion rate.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EurUsdConversionRateResponse> GetEURUSDConversionRateAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trading fees
        /// </summary>
        /// <remarks>
        /// Return all trading fees.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<FeeTradingResponse>> GetAllTradingFeesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trading fee for market
        /// </summary>
        /// <remarks>
        /// Return trading fees for market.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FeeTradingResponse> GetTradingFeesForCurrencyAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdrawal fees
        /// </summary>
        /// <remarks>
        /// Return withdrawal fees.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<FeeWithdrawalResponse>> GetAllWithdrawalFeesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdrawal fee for currency
        /// </summary>
        /// <remarks>
        /// Return withdrawal fee for currency.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid network selection | The selected network is not supported for 'currency'. Please select a compatible network for it. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FeeWithdrawalResponse> GetWithdrawalFeeForCurrencyAsync(string currency, FeeWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Instant convert address
        /// </summary>
        /// <remarks>
        /// Shows transactions for the instant convert address.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Address not found. | Provided address is wrong. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<InstantConvertAddressInfoResponse>> GetLiquidationAddressTransactionsAsync(InstantConvertAddressInfoRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// New instant convert address
        /// </summary>
        /// <remarks>
        /// Creates a new instant convert address which will automatically sell your crypto for specified fiat currency.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing liquidation_currency parameter. | Parameter liquidation_currency is required for this call. |
        /// <br/>| Invalid currency / Currency [...] not supported. | Invalid liquidation_currency. |
        /// <br/>| Cannot create new address, please try later. | At the moment we can't create new deposit address. Try again later. |
        /// <br/>| Invalid address format. | Invalid address_format. |
        /// <br/>| Your trading features are currently disabled | No new liquidation addresses can be created at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<NewInstantConvertAddressResponse> RequestNewLiquidationAddressAsync(NewInstantConvertAddressRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trading markets
        /// </summary>
        /// <remarks>
        /// Returns all markets that can be traded on selected account.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<TradingPair>> GetUserTradingMarketsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// OHLC data
        /// </summary>
        /// <remarks>
        /// Returns OHLC (Open High Low Close) data.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing data for required field. | Step and limit parameters are missing. |
        /// <br/>| Not a valid choice. | Value entered in parameter is invalid. |
        /// <br/>| Must be between 1 and 1000. | Limit value must be between 1 and 1000. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <param name="step">Timeframe in seconds.</param>
        /// <param name="limit">Limit OHLC results.</param>
        /// <param name="start">Unix timestamp from when OHLC data will be started.</param>
        /// <param name="end">Unix timestamp to when OHLC data will be shown.If none from start or end timestamps are posted then endpoint returns OHLC data to current unixtime. If both start and end timestamps are posted, end timestamp will be used.</param>
        /// <param name="exclude_current_candle">If set, results won't include current (open) candle.</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetOHLCDataAsync(Step step, int limit, string market_symbol, int? start = null, int? end = null, bool? exclude_current_candle = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Open orders
        /// </summary>
        /// <remarks>
        /// Return user's open orders. This API call is cached for 10 seconds. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<OpenOrdersAllResponse>> GetAllOpenOrdersAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Open orders for market
        /// </summary>
        /// <remarks>
        /// Return user's open orders for market. This API call is cached for 10 seconds. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<OpenOrdersPairResponse>> GetOpenOrdersForMarketAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Order book
        /// </summary>
        /// <remarks>
        /// Returns order book data.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| POST method not allowed for this request. | HTTP method other than GET used. |
        /// <br/>| Invalid GET parameter. | Missing group parameter. |
        /// <br/>| Internal error. | Order book unavailable. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <param name="group">The group parameter is used for accessing different data from order book. Possible values are 0 (orders are not grouped at same price), 1 (orders are grouped at same price - default) or 2 (orders with their order ids are not grouped at same price).</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OrderBookResponse> GetOrderBookAsync(string market_symbol, int? group = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Order status
        /// </summary>
        /// <remarks>
        /// Returns order status. This call will be executed on the account (Sub or Main), to which the
        /// <br/>used API key is bound to. Order can be fetched by using either id or client_order_id parameter. For closed
        /// <br/>orders, this call only returns information for the last 30 days. 'Order not found' error will be returned
        /// <br/>for orders outside this time range.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing id POST param | Id parameter missing. |
        /// <br/>| Invalid order id | Order id parameter can only be number. |
        /// <br/>| Order not found. | Order with that id was not found in our system. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OrderStatusResponse> GetOrderStatusAsync(OrderStatusRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke all API access
        /// </summary>
        /// <remarks>
        /// Revoke all API keys across all user's accounts.
        /// </remarks>
        /// <param name="body">This endpoint does not expect a request body.</param>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RevokedAPIKeySchema> RevokeAllAPIKeysAsync(EmptySchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Ripple IOU deposit address
        /// </summary>
        /// <remarks>
        /// This API call is cached for 60 seconds. This call will be executed on the account (Sub or Main), to which
        /// <br/>the used API key is bound to. This endpoint supports withdrawals of USD, BTC or EUR* IOU on the XRP Ledger.
        /// <br/>
        /// <br/>*IOUs are supported globally except for Singapore. Also, EUR-IOUs are not supported in the US.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| Your deposits are currently disabled | No new deposits can be made at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RippleIOUDepositAddressResponse> GetRippleIOUDepositAddressAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Ripple IOU withdrawal
        /// </summary>
        /// <remarks>
        /// This call will be executed on the account (Sub or Main), to which the used
        /// <br/>API key is bound to. This endpoint supports withdrawals of USD, BTC or EUR* IOU on the XRP Ledger.
        /// <br/>
        /// <br/>*IOUs are supported globally except for Singapore. Also, EUR-IOUs are not supported in the US.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or address POST parameters | One or both parameters missing. |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| 'crypto_currency' withdrawals are currently unavailable for your account | Contact support for additional information. |
        /// <br/>| Not allowed to withdraw to specified 'crypto_currency' address | API key is set for withdrawing to another 'crypto_currency' address. |
        /// <br/>| Enter a number. Use "." as a decimal point | Amount parameter can only be number. |
        /// <br/>| You have only 'available' 'crypto_currency' available. Check your account balance for details | Account has less available 'crypto_currency' than are required to make this withdrawal. |
        /// <br/>| Your withdrawals are currently disabled | No new withdrawals can be opened at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>| Ensure this value is greater than or equal to 'minimum_withdrawal_amount' | Minimum withdrawal amount is 'minimum_withdrawal_amount'. |
        /// <br/>| Ensure this value has at least 'minimum_address_length' characters (it has x). Ensure this value has at most 'maximum_address_length' characters (it has x). | Address parameter must be between 'minimum_address_length' and 'maximum_address_length' characters long. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RippleIOUWithdrawalResponse> RequestRippleIOUWithdrawalAsync(RippleIOUWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sell instant order
        /// </summary>
        /// <remarks>
        /// Open an instant sell order. By placing an instant order you acknowledge that the execution of your order
        /// <br/>depends on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only sell 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BuySellOrderResponse> OpenInstantSellOrderAsync(string market_symbol, SellInstantOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sell market order
        /// </summary>
        /// <remarks>
        /// Open a sell market order. By placing a market order you acknowledge that the execution of your order depends
        /// <br/>on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only sell 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| No buy orders for currency pair 'currency_pair' | The buy side of the orderbook for 'currency_pair' is empty, therefore a market sell order cannot be placed. |
        /// <br/>| Maximum market sell amount at the moment is 'amount' 'currency'. Please use limit order instead. | Order amount exceeds the limit amount set for market sell orders. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BuySellOrderResponse> OpenMarketSellOrderAsync(string market_symbol, BuySellMarketOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sell limit order
        /// </summary>
        /// <remarks>
        /// Open a sell limit order. This call will be executed on the account (Sub or Main), to which the used API key
        /// <br/>is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| Price is more than 20% below market price. | Order price must not exceed 20% of current price. |
        /// <br/>| You have only 'available_btc' BTC available. Check your account balance for details. | Account has less 'available_btc' than is required to make this order. |
        /// <br/>| Buy if executed price must be lower than sell price. | 'limit_price' must be lower than 'price' parameter. |
        /// <br/>| Both limit_price and daily_order cannot be set. | Only one of those parameters can be set. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BuySellOrderResponse> OpenLimitSellOrderAsync(string market_symbol, BuySellLimitOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// All currency pairs tickers
        /// </summary>
        /// <remarks>
        /// Return ticker data for all currency pairs. Passing any GET parameters, will result in your request being rejected.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<TickerWithPairResponse>> GetCurrencyPairTickersAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Market ticker
        /// </summary>
        /// <remarks>
        /// Return ticker data for the requested currency pair. Passing any GET parameters, will result in your request being rejected.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TickerResponse> GetMarketTickerAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Hourly  ticker
        /// </summary>
        /// <remarks>
        /// Return hourly ticker data for the requested currency pair. Passing any GET parameters, will result in your request being rejected.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TickerHourResponse> GetHourlyCurrencyPairTickerAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// TradingPairs
        /// </summary>
        /// <remarks>
        /// View that returns list of all trading pairs.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<TradingPairsInfoResponseSchema>> GetTradingPairsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transactions
        /// </summary>
        /// <remarks>
        /// Return transaction data from a given time frame.
        /// </remarks>
        /// <param name="time">The time interval from which we want the transactions to be returned. Possible values are minute, hour (default) or day.</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TransactionsResponse> GetTransactionsAsync(string market_symbol, Time? time = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer balance from Main to Sub Account
        /// </summary>
        /// <remarks>
        /// Transfers the desired balance from your Main Account to a Sub Account, specified by the subAccount
        /// <br/>parameter. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| You have only 'available' 'currency' available. Check your account balance for details. | Account has less 'available_currency' than is required to make this transfer. |
        /// <br/>| Select a valid choice. X is not one of the available choices. | X is not valid currency. Select a valid currency. |
        /// <br/>| Sub account with identifier "X" does not exist. | Can't find sub account with id X. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TransferToFromMainResponse> TransferFromMainToSubAsync(TransferToFromMainRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer balance from Sub to Main account
        /// </summary>
        /// <remarks>
        /// Transfers the desired balance from a Sub Account to your Main Account.
        /// <br/>Can be called by either the Main Account or a Sub Account, but requires a permission in both cases.
        /// <br/>The subAccount parameter must be provided if the Main Account is initiating the call.
        /// <br/>If a Sub Account is making the call, then it is the target Sub Account for the transfer and no further
        /// <br/>clarification is required.
        /// <br/>In that case, passing this parameter will have no additional effect.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| You have only 'available' 'currency' available. Check your account balance for details. | Account has less 'available_currency' than is required to make this transfer. |
        /// <br/>| Select a valid choice. X is not one of the available choices. | X is not valid currency. Select a valid currency. |
        /// <br/>| Sub account with identifier "X" does not exist. | Can't find sub account with id X. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TransferToFromMainResponse> TransferFromSubToMainAsync(TransferToFromMainRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all contacts
        /// </summary>
        /// <remarks>
        /// Returns all contacts that have been previously created.
        /// <br/>These can then be used to provide the originator or beneficiary details of a Travel Rule message, when
        /// <br/>transferring crypto from/to the platform.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully retrieved the list of contacts.                               |
        /// <br/>| 403           |             | You do not have sufficient permissions to access this endpoint.            |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<ContactSchema>> GetAllContactsAsync(int? per_page = null, int? page = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create contact
        /// </summary>
        /// <remarks>
        /// Enables a contact to be created and relevant information to be provided and stored.
        /// <br/>This can then be used to provide the originator or beneficiary details of a Travel Rule message, when
        /// <br/>transferring crypto from/to the platform.
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 201           |             | Successfully created the contact.                                          |
        /// <br/>| 403           |             | You do not have sufficient permissions to access this endpoint.            |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ContactSchema> CreateContactAsync(ContactSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get contact
        /// </summary>
        /// <remarks>
        /// Returns a specific contact that has been previously created.
        /// <br/>This can then be used to provide the originator or beneficiary details of a Travel Rule message, when
        /// <br/>transferring crypto from/to the platform.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully retrieved the contact.                                        |
        /// <br/>| 403           |             | You do not have sufficient permissions to access this endpoint.            |
        /// <br/>| 404           |             | Contact with given contact uuid is not found.                              |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ContactSchema> GetContactAsync(string contact_uuid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// VASP list
        /// </summary>
        /// <remarks>
        /// A list of Virtual Asset Service Providers needed to comply with the Travel Rule.
        /// <br/>These may be needed when transferring cryptocurrency from/to the platform.
        /// <br/>This is required in cases where the originating or destination address of the crypto transfer
        /// <br/>is hosted by a VASP.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully retrieved the vasp list.                                      |
        /// <br/>| 400           |             | Could not fetch VASP list, service unavailable.                            |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> VaspListAsync(int? per_page = null, int? page = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// User transactions
        /// </summary>
        /// <remarks>
        /// Return user transactions from a given time frame. This call will be executed on the account (Sub
        /// <br/>or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid offset | Offset parameter should be number from 0 to 200000. |
        /// <br/>| Limit too large | Max value of limit parameter is 1000. |
        /// <br/>| Invalid limit | Limit parameter should be number from 1 to 1000. |
        /// <br/>| Invalid sort parameter | Sort parameter can only be 'asc' or 'desc'. |
        /// <br/>| Invalid since_timestamp parameter | since_timestamp can only be digit. |
        /// <br/>| since_timestamp parameter must be higher than .. | Make sure that since_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert since_timestamp parameter | Check the value of since_timestamp parameter. |
        /// <br/>| Invalid until_timestamp parameter | until_timestamp can only be digit. |
        /// <br/>| until_timestamp parameter must be higher than .. | Make sure that until_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert until_timestamp parameter | Check the value of until_timestamp parameter. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<UserTransactionsResponse>> GetUserTransactionsAsync(UserTransactionsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// User transactions for market
        /// </summary>
        /// <remarks>
        /// Return user transactions for a market from a given time frame. This call will be executed on
        /// <br/>the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid offset | Offset parameter should be number from 0 to 200000. |
        /// <br/>| Limit too large | Max value of limit parameter is 1000. |
        /// <br/>| Invalid limit | Limit parameter should be number from 1 to 1000. |
        /// <br/>| Invalid sort parameter | Sort parameter can only be 'asc' or 'desc'. |
        /// <br/>| Invalid since_timestamp parameter | since_timestamp can only be digit. |
        /// <br/>| since_timestamp parameter must be higher than .. | Make sure that since_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert since_timestamp parameter | Check the value of since_timestamp parameter. |
        /// <br/>| Invalid until_timestamp parameter | until_timestamp can only be digit. |
        /// <br/>| until_timestamp parameter must be higher than .. | Make sure that until_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert until_timestamp parameter | Check the value of until_timestamp parameter. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.List<UserTransactionsResponse>> GetUserTransactionsForMarketAsync(string market_symbol, UserTransactionsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Websockets token
        /// </summary>
        /// <remarks>
        /// Generates token required for subscribing to private WebSocket channels.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WebsocketsTokenResponse> GetWebsocketTokenAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdrawal requests
        /// </summary>
        /// <remarks>
        /// Return user's withdrawal requests. This call will be executed on the account (Sub or Main), to which the
        /// <br/>used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid timedelta | Timedelta needs to have only numeric characters. |
        /// <br/>| Timedelta too large | Timedelta too large. |
        /// <br/>| Invalid offset | Offset needs to be numeric characters between 0 and 200000. |
        /// <br/>| Invalid limit | Limit needs to be numeric characters between 1 and 1000. |
        /// <br/>| Invalid id | Id needs to have only numeric characters. |
        /// <br/>| Both limit and offset must be present | Both limit and offset must be present. |
        /// <br/>| Too many parameters | Pick one or combination of parameters and run again. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WithdrawalRequestsResponse> GetWithdrawalRequestsAsync(WithdrawalRequestsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel bank or crypto withdrawal
        /// </summary>
        /// <remarks>
        /// Cancels a bank or crypto withdrawal request. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Cancelling bank withdrawals with sub account API keys is not supported. | This API endpoint can only be utilized by your main account. |
        /// <br/>| Missing parameters: [...] | Parameters stated in the list ([...]) are required for this call. |
        /// <br/>| No active bank withdrawal with id=X found. | Could not find any active bank withdrawal with the id X. Will return the same response for already cancelled withdrawal requests. |
        /// <br/>| Cannot cancel a withdrawal in process (id=X). | The bank withdrawal request with id=X is currently being processed and cannot be cancelled. |
        /// <br/>| Your withdrawals are currently disabled | No bank withdrawals can be canceled at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CancelBankWithdrawalResponse> CancelWithdrawalAsync(CancelBankOrCryptoWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Open bank withdrawal
        /// </summary>
        /// <remarks>
        /// Opens a bank withdrawal request (SEPA or international). Withdrawal requests opened via API are
        /// <br/>automatically confirmed (no confirmation e-mail will be sent), but are processed just like withdrawals
        /// <br/>opened through the platform's interface. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Opening bank withdrawals with sub account API keys is not supported. | This API endpoint can only be utilized by your main account. |
        /// <br/>| 'X': ['This field is required.'] | Parameter X is required for this call. |
        /// <br/>| 'X': ['Select a valid choice. Y is not one of the available choices.'] | Y is not a valid value for parameter X. |
        /// <br/>| Bank withdrawals temporarily disabled. | No new bank withdrawals can be opened at this time. |
        /// <br/>| Unsupported withdrawal type (must be either SEPA or international). | When opening bank withdrawals, you must specify one of the two supported types: SEPA or international. |
        /// <br/>| When opening bank withdrawals, you must specify one of the two supported types: SEPA or international. | To open this withdrawal, your balance must have at least 'amount' of target currency available. |
        /// <br/>| 'X': ['Enter a number. Use "." as a decimal point.'] | Parameter X can only be a decimal number. |
        /// <br/>| Your withdrawals are currently disabled | No new withdrawals can be opened at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OpenBankWithdrawalResponse> RequestFiatWithdrawalAsync(OpenBankWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fiat withdrawal status
        /// </summary>
        /// <remarks>
        /// Checks the status of a fiat withdrawal request. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Performing bank withdrawal status checks with sub account API keys is not supported. | This API endpoint can only be utilized by your main account. |
        /// <br/>| Missing parameters: [...]. | Parameters stated in the list ([...]) are required for this call. |
        /// <br/>| No bank withdrawal with id=X found. | Could not find any bank withdrawal with the id X. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BankWithdrawalStatusResponse> GetFiatWithdrawalStatusAsync(BankWithdrawalStatusRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crypto deposit address
        /// </summary>
        /// <remarks>
        /// This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| Your deposits are currently disabled | No new deposits can be made at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>| Invalid network selection | The selected network is not supported for 'currency'. Please select a compatible network for it. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DepositAddressResponse> GetCryptoDepositAddressAsync(string currency, DepositAddressRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crypto withdrawal
        /// </summary>
        /// <remarks>
        /// Request a crypto withdrawal.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or address POST parameters | One or both parameters missing. |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| 'crypto_currency' withdrawals are currently unavailable for your account | Contact support for additional information. |
        /// <br/>| Not allowed to withdraw to specified 'crypto_currency' address | API key is set for withdrawing to another 'crypto_currency' address. |
        /// <br/>| Enter a number. Use "." as a decimal point | Amount parameter can only be number. |
        /// <br/>| You have only 'available' 'crypto_currency' available. Check your account balance for details | Account has less available 'crypto_currency' than are required to make this withdrawal. |
        /// <br/>| Your withdrawals are currently disabled | No new withdrawals can be opened at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>| Ensure this value is greater than or equal to 'minimum_withdrawal_amount' | Minimum withdrawal amount is 'minimum_withdrawal_amount'. |
        /// <br/>| Ensure this value has at least 'minimum_address_length' characters (it has x). Ensure this value has at most 'maximum_address_length' characters (it has x). | Address parameter must be between 'minimum_address_length' and 'maximum_address_length' characters long. |
        /// <br/>| Invalid network selection | The selected network is not supported for 'currency'. Please select a compatible network for it. |
        /// <br/>| Contact does not exist | Review and validate the contact_uuid to ensure it matches an existing contact, you may also create contacts at /v2/travel_rule/contacts endpoint |
        /// <br/>| Vasp does not exist | Verify that the vasp_uuid exists within the /v2/travel_rule/vasps endpoint. |
        /// <br/>| contact_uuid: You must set this field because contact_thirdparty=True | contact_uuid must be provided if withdrawing to a third party |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CryptoWithdrawalResponse> RequestCryptoWithdrawalAsync(string currency, CryptoWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BitstampHttpClient : IBitstampHttpClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public BitstampHttpClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            _httpClient = httpClient;
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Account balances
        /// </summary>
        /// <remarks>
        /// Return account balances.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<AccountBalancesResponse>> GetAccountBalancesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/account_balances/"
                    urlBuilder_.Append("api/v2/account_balances/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<AccountBalancesResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Account balance for currency
        /// </summary>
        /// <remarks>
        /// Return account balances for currency.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AccountBalancesResponse> GetAccountBalancesForCurrencyAsync(string currency, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (currency == null)
                throw new System.ArgumentNullException("currency");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/account_balances/{currency}/"
                    urlBuilder_.Append("api/v2/account_balances/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(currency, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AccountBalancesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unconfirmed bitcoin deposits
        /// </summary>
        /// <remarks>
        /// This API call is cached for 60 seconds. This call will be executed on the account (Sub or Main), to which
        /// <br/>the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DepositAddressResponse> GetUnconfirmedBTCDepositsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/btc_unconfirmed/"
                    urlBuilder_.Append("api/v2/btc_unconfirmed/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DepositAddressResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Buy instant order
        /// </summary>
        /// <remarks>
        /// Open a buy instant order. By placing an instant order you acknowledge that the execution of your order
        /// <br/>depends on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only buy 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| Maximum market buy amount at the moment is 'amount' 'currency'. Please use limit order instead. | Order amount exceeds the limit amount set for market buy orders. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuySellOrderResponse> OpenInstantBuyOrderAsync(string market_symbol, BuyInstantOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/buy/instant/{market_symbol}/"
                    urlBuilder_.Append("api/v2/buy/instant/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuySellOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Buy market order
        /// </summary>
        /// <remarks>
        /// Open a buy market order. By placing a market order you acknowledge that the execution of your order depends
        /// <br/>on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only buy 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| Maximum market buy amount at the moment is 'amount' 'currency'. Please use limit order instead. | Order amount exceeds the limit amount set for market buy orders. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuySellOrderResponse> OpenMarketBuyOrderAsync(string market_symbol, BuySellMarketOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/buy/market/{market_symbol}/"
                    urlBuilder_.Append("api/v2/buy/market/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuySellOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Buy limit order
        /// </summary>
        /// <remarks>
        /// Open a buy limit order. This call will be executed on the account (Sub or Main), to which the used API key
        /// <br/>is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| Price is more than 20% above market price. | Order price must not exceed 20% of current price. |
        /// <br/>| You need 'order_value' USD to open that order. You have only 'available_fiat' USD available. Check your account balance for details. | Account has less 'available_fiat' than is required to make this order. |
        /// <br/>| Sell if executed price must be higher than buy price. | 'limit_price' must be larger than 'price' parameter. |
        /// <br/>| Both limit_price and daily_order cannot be set. | Only one of those parameters can be set. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuySellOrderResponse> OpenLimitBuyOrderAsync(string market_symbol, BuySellLimitOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/buy/{market_symbol}/"
                    urlBuilder_.Append("api/v2/buy/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuySellOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel all orders
        /// </summary>
        /// <remarks>
        /// Cancel all open orders. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CancelAllOrdersResponse> CancelAllOrdersAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/cancel_all_orders/"
                    urlBuilder_.Append("api/v2/cancel_all_orders/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CancelAllOrdersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel all orders for market
        /// </summary>
        /// <remarks>
        /// Cancel all open orders for a market. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CancelAllOrdersResponse> CancelOrdersForMarketAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/cancel_all_orders/{market_symbol}/"
                    urlBuilder_.Append("api/v2/cancel_all_orders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CancelAllOrdersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel order
        /// </summary>
        /// <remarks>
        /// Cancel an order. This call will be executed on the account (Sub or Main), to which the used API key is
        /// <br/>bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing id POST param. | Id parameter missing. |
        /// <br/>| Invalid id POST param. | Id parameter must be a positive integer. |
        /// <br/>| Invalid client_cancel_id POST param. | client_cancel_id parameter can contain at most 180 characters. |
        /// <br/>| Order not found | Order with that id was not found in orderbook. Order might already be filled or canceled. Please check order status. |
        /// <br/>| Order cancellation failed due to internal error. Please try again. | Please retry cancelling order. |
        /// <br/>| Order cancelattion failed due to trade halt. | You can cancel order after trade halt is lifted. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CancelOrderResponse> CancelOrderAsync(CancelOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/cancel_order/"
                    urlBuilder_.Append("api/v2/cancel_order/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CancelOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crypto transactions
        /// </summary>
        /// <remarks>
        /// Return user's crypto transactions. This call will be executed on the account, to which the used API key is
        /// <br/>bound to. This call is for your main account only.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Limit too large | Max value of limit parameter is 1000. |
        /// <br/>| Invalid limit | Limit parameter should be number from 1 to 1000. |
        /// <br/>| Offset too large | Offset parameter cannot be larger than 200000. |
        /// <br/>| Invalid offset | Offset parameter needs to be a number from 0 to 200000. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CryptoTransactionsResponse> GetCryptoUserTransactionsAsync(CryptoTransactionsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/crypto-transactions/"
                    urlBuilder_.Append("api/v2/crypto-transactions/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CryptoTransactionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Currencies
        /// </summary>
        /// <remarks>
        /// Returns list of all currencies with basic data.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<CurrencySchema>> GetCurrenciesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/currencies/"
                    urlBuilder_.Append("api/v2/currencies/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<CurrencySchema>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Subscribe to earn
        /// </summary>
        /// <remarks>
        /// Subscribe given amount to lending / staking.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                              |
        /// <br/>|---------------|-------------|-------------------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully subscribed to earn.                                                    |
        /// <br/>| 400           | API5001     | Earn request amount too low.                                                        |
        /// <br/>| 400           | API5002     | Earn request amount too high.                                                       |
        /// <br/>| 400           | API5003     | Decimal places in amount exceed maximum allowed.                                    |
        /// <br/>| 400           | API5004     | Operation is unsupported.                                                           |
        /// <br/>| 400           | API5005     | Operation is currently unavailable, please try again later.                         |
        /// <br/>| 400           | API5006     | Required personal information is missing, please reach out to support@bitstamp.net. |
        /// <br/>| 400           | API5007     | Operation is unavailable, please reach out to support@bitstamp.net.                 |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                                              |
        /// <br/>| 403           |             | This feature is not available for your account.                                     |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task EarnSubscribeAsync(EarnSubscriptionSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/earn/subscribe/"
                    urlBuilder_.Append("api/v2/earn/subscribe/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("ForbiddenError | Provided data is invalid.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get earn subscriptions
        /// </summary>
        /// <remarks>
        /// Get earn subscriptions for user.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Returned earn subscriptions                                 |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<EarnSubscriptionsSchema>> EarnSubscriptionsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/earn/subscriptions/"
                    urlBuilder_.Append("api/v2/earn/subscriptions/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<EarnSubscriptionsSchema>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Manage subscription settings
        /// </summary>
        /// <remarks>
        /// Manage subscription settings (opt in, opt out). Currently only supported for staking.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully update subscription setting.                   |
        /// <br/>| 400           | API5004     | Operation is unsupported.                                   |
        /// <br/>| 400           | API5005     | Operation is currently unavailable, please try again later. |
        /// <br/>| 400           | API5008     | Already opted in.                                           |
        /// <br/>| 400           | API5009     | Not opted in.                                               |
        /// <br/>| 400           | API5010     | Insufficient balance.                                       |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// <br/>| 403           |             | This feature is not available for your account.             |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task EarnSubscriptionsSettingAsync(EarnSubscriptionSettingSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/earn/subscriptions/setting/"
                    urlBuilder_.Append("api/v2/earn/subscriptions/setting/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("ForbiddenError | Provided data is invalid.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get earn transactions
        /// </summary>
        /// <remarks>
        /// Get earn transaction history.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Returned earn transaction history.                          |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// </remarks>
        /// <param name="currency">Currency</param>
        /// <param name="limit">Limit result to that many events (default: 100; maximum: 1000)</param>
        /// <param name="offset">Skip that many events before returning results (default: 0, maximum: 200000)</param>
        /// <param name="quote_currency">Currency in which value is calculated</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<EarnTransactionSchema>> EarnTransactionsAsync(string currency = null, int? limit = null, int? offset = null, string quote_currency = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/earn/transactions/"
                    urlBuilder_.Append("api/v2/earn/transactions/");
                    urlBuilder_.Append('?');
                    if (currency != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("currency")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(currency, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (offset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("offset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (quote_currency != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("quote_currency")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(quote_currency, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<EarnTransactionSchema>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unsubscribe from earn
        /// </summary>
        /// <remarks>
        /// Unsubscribe given amount from lending / staking.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                      |
        /// <br/>|---------------|-------------|-------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully unsubscribed from earn.                        |
        /// <br/>| 400           | API5001     | Earn request amount too low.                                |
        /// <br/>| 400           | API5002     | Earn request amount too high.                               |
        /// <br/>| 400           | API5003     | Decimal places in amount exceed maximum allowed.            |
        /// <br/>| 400           | API5004     | Operation is unsupported.                                   |
        /// <br/>| 400           | API5005     | Operation is currently unavailable, please try again later. |
        /// <br/>| 400           | API5011     | Something went wrong, try again later.                      |
        /// <br/>| 400           | API5012     | Staked balance is insufficient.                             |
        /// <br/>| 403           |             | This feature is not available for your account.             |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task EarnUnsubscribeAsync(EarnSubscriptionSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/earn/unsubscribe/"
                    urlBuilder_.Append("api/v2/earn/unsubscribe/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("ForbiddenError | Provided data is invalid.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// EUR/USD conversion rate
        /// </summary>
        /// <remarks>
        /// Return EUR/USD conversion rate.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EurUsdConversionRateResponse> GetEURUSDConversionRateAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/eur_usd/"
                    urlBuilder_.Append("api/v2/eur_usd/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EurUsdConversionRateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trading fees
        /// </summary>
        /// <remarks>
        /// Return all trading fees.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<FeeTradingResponse>> GetAllTradingFeesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/fees/trading/"
                    urlBuilder_.Append("api/v2/fees/trading/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<FeeTradingResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trading fee for market
        /// </summary>
        /// <remarks>
        /// Return trading fees for market.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FeeTradingResponse> GetTradingFeesForCurrencyAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/fees/trading/{market_symbol}/"
                    urlBuilder_.Append("api/v2/fees/trading/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FeeTradingResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdrawal fees
        /// </summary>
        /// <remarks>
        /// Return withdrawal fees.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<FeeWithdrawalResponse>> GetAllWithdrawalFeesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/fees/withdrawal/"
                    urlBuilder_.Append("api/v2/fees/withdrawal/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<FeeWithdrawalResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdrawal fee for currency
        /// </summary>
        /// <remarks>
        /// Return withdrawal fee for currency.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid network selection | The selected network is not supported for 'currency'. Please select a compatible network for it. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FeeWithdrawalResponse> GetWithdrawalFeeForCurrencyAsync(string currency, FeeWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (currency == null)
                throw new System.ArgumentNullException("currency");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/fees/withdrawal/{currency}/"
                    urlBuilder_.Append("api/v2/fees/withdrawal/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(currency, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FeeWithdrawalResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Instant convert address
        /// </summary>
        /// <remarks>
        /// Shows transactions for the instant convert address.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Address not found. | Provided address is wrong. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<InstantConvertAddressInfoResponse>> GetLiquidationAddressTransactionsAsync(InstantConvertAddressInfoRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/instant_convert_address/info/"
                    urlBuilder_.Append("api/v2/instant_convert_address/info/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<InstantConvertAddressInfoResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// New instant convert address
        /// </summary>
        /// <remarks>
        /// Creates a new instant convert address which will automatically sell your crypto for specified fiat currency.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing liquidation_currency parameter. | Parameter liquidation_currency is required for this call. |
        /// <br/>| Invalid currency / Currency [...] not supported. | Invalid liquidation_currency. |
        /// <br/>| Cannot create new address, please try later. | At the moment we can't create new deposit address. Try again later. |
        /// <br/>| Invalid address format. | Invalid address_format. |
        /// <br/>| Your trading features are currently disabled | No new liquidation addresses can be created at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<NewInstantConvertAddressResponse> RequestNewLiquidationAddressAsync(NewInstantConvertAddressRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/instant_convert_address/new/"
                    urlBuilder_.Append("api/v2/instant_convert_address/new/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NewInstantConvertAddressResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Trading markets
        /// </summary>
        /// <remarks>
        /// Returns all markets that can be traded on selected account.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<TradingPair>> GetUserTradingMarketsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/my_markets/"
                    urlBuilder_.Append("api/v2/my_markets/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<TradingPair>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// OHLC data
        /// </summary>
        /// <remarks>
        /// Returns OHLC (Open High Low Close) data.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing data for required field. | Step and limit parameters are missing. |
        /// <br/>| Not a valid choice. | Value entered in parameter is invalid. |
        /// <br/>| Must be between 1 and 1000. | Limit value must be between 1 and 1000. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <param name="step">Timeframe in seconds.</param>
        /// <param name="limit">Limit OHLC results.</param>
        /// <param name="start">Unix timestamp from when OHLC data will be started.</param>
        /// <param name="end">Unix timestamp to when OHLC data will be shown.If none from start or end timestamps are posted then endpoint returns OHLC data to current unixtime. If both start and end timestamps are posted, end timestamp will be used.</param>
        /// <param name="exclude_current_candle">If set, results won't include current (open) candle.</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> GetOHLCDataAsync(Step step, int limit, string market_symbol, int? start = null, int? end = null, bool? exclude_current_candle = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            if (step == null)
                throw new System.ArgumentNullException("step");

            if (limit == null)
                throw new System.ArgumentNullException("limit");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/ohlc/{market_symbol}/"
                    urlBuilder_.Append("api/v2/ohlc/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("step")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(step, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (start != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("start")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(start, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (end != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("end")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(end, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclude_current_candle != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclude_current_candle")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclude_current_candle, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Open orders
        /// </summary>
        /// <remarks>
        /// Return user's open orders. This API call is cached for 10 seconds. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<OpenOrdersAllResponse>> GetAllOpenOrdersAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/open_orders/"
                    urlBuilder_.Append("api/v2/open_orders/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<OpenOrdersAllResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Open orders for market
        /// </summary>
        /// <remarks>
        /// Return user's open orders for market. This API call is cached for 10 seconds. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<OpenOrdersPairResponse>> GetOpenOrdersForMarketAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/open_orders/{market_symbol}/"
                    urlBuilder_.Append("api/v2/open_orders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<OpenOrdersPairResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Order book
        /// </summary>
        /// <remarks>
        /// Returns order book data.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| POST method not allowed for this request. | HTTP method other than GET used. |
        /// <br/>| Invalid GET parameter. | Missing group parameter. |
        /// <br/>| Internal error. | Order book unavailable. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <param name="group">The group parameter is used for accessing different data from order book. Possible values are 0 (orders are not grouped at same price), 1 (orders are grouped at same price - default) or 2 (orders with their order ids are not grouped at same price).</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OrderBookResponse> GetOrderBookAsync(string market_symbol, int? group = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/order_book/{market_symbol}/"
                    urlBuilder_.Append("api/v2/order_book/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append('?');
                    if (group != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("group")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(group, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OrderBookResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Order status
        /// </summary>
        /// <remarks>
        /// Returns order status. This call will be executed on the account (Sub or Main), to which the
        /// <br/>used API key is bound to. Order can be fetched by using either id or client_order_id parameter. For closed
        /// <br/>orders, this call only returns information for the last 30 days. 'Order not found' error will be returned
        /// <br/>for orders outside this time range.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing id POST param | Id parameter missing. |
        /// <br/>| Invalid order id | Order id parameter can only be number. |
        /// <br/>| Order not found. | Order with that id was not found in our system. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OrderStatusResponse> GetOrderStatusAsync(OrderStatusRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/order_status/"
                    urlBuilder_.Append("api/v2/order_status/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OrderStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Revoke all API access
        /// </summary>
        /// <remarks>
        /// Revoke all API keys across all user's accounts.
        /// </remarks>
        /// <param name="body">This endpoint does not expect a request body.</param>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RevokedAPIKeySchema> RevokeAllAPIKeysAsync(EmptySchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/revoke_all_api_keys/"
                    urlBuilder_.Append("api/v2/revoke_all_api_keys/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RevokedAPIKeySchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("Provided data is invalid.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Ripple IOU deposit address
        /// </summary>
        /// <remarks>
        /// This API call is cached for 60 seconds. This call will be executed on the account (Sub or Main), to which
        /// <br/>the used API key is bound to. This endpoint supports withdrawals of USD, BTC or EUR* IOU on the XRP Ledger.
        /// <br/>
        /// <br/>*IOUs are supported globally except for Singapore. Also, EUR-IOUs are not supported in the US.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| Your deposits are currently disabled | No new deposits can be made at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RippleIOUDepositAddressResponse> GetRippleIOUDepositAddressAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/ripple_address/"
                    urlBuilder_.Append("api/v2/ripple_address/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RippleIOUDepositAddressResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Ripple IOU withdrawal
        /// </summary>
        /// <remarks>
        /// This call will be executed on the account (Sub or Main), to which the used
        /// <br/>API key is bound to. This endpoint supports withdrawals of USD, BTC or EUR* IOU on the XRP Ledger.
        /// <br/>
        /// <br/>*IOUs are supported globally except for Singapore. Also, EUR-IOUs are not supported in the US.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or address POST parameters | One or both parameters missing. |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| 'crypto_currency' withdrawals are currently unavailable for your account | Contact support for additional information. |
        /// <br/>| Not allowed to withdraw to specified 'crypto_currency' address | API key is set for withdrawing to another 'crypto_currency' address. |
        /// <br/>| Enter a number. Use "." as a decimal point | Amount parameter can only be number. |
        /// <br/>| You have only 'available' 'crypto_currency' available. Check your account balance for details | Account has less available 'crypto_currency' than are required to make this withdrawal. |
        /// <br/>| Your withdrawals are currently disabled | No new withdrawals can be opened at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>| Ensure this value is greater than or equal to 'minimum_withdrawal_amount' | Minimum withdrawal amount is 'minimum_withdrawal_amount'. |
        /// <br/>| Ensure this value has at least 'minimum_address_length' characters (it has x). Ensure this value has at most 'maximum_address_length' characters (it has x). | Address parameter must be between 'minimum_address_length' and 'maximum_address_length' characters long. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RippleIOUWithdrawalResponse> RequestRippleIOUWithdrawalAsync(RippleIOUWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/ripple_withdrawal/"
                    urlBuilder_.Append("api/v2/ripple_withdrawal/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RippleIOUWithdrawalResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sell instant order
        /// </summary>
        /// <remarks>
        /// Open an instant sell order. By placing an instant order you acknowledge that the execution of your order
        /// <br/>depends on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only sell 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuySellOrderResponse> OpenInstantSellOrderAsync(string market_symbol, SellInstantOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/sell/instant/{market_symbol}/"
                    urlBuilder_.Append("api/v2/sell/instant/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuySellOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sell market order
        /// </summary>
        /// <remarks>
        /// Open a sell market order. By placing a market order you acknowledge that the execution of your order depends
        /// <br/>on the market conditions and that these conditions may be subject to sudden changes that cannot be
        /// <br/>foreseen. This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| You can only sell 'amount' 'currency'. Check your account balance for details. | Account has less 'available_currency' than is required to make this order. |
        /// <br/>| No buy orders for currency pair 'currency_pair' | The buy side of the orderbook for 'currency_pair' is empty, therefore a market sell order cannot be placed. |
        /// <br/>| Maximum market sell amount at the moment is 'amount' 'currency'. Please use limit order instead. | Order amount exceeds the limit amount set for market sell orders. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuySellOrderResponse> OpenMarketSellOrderAsync(string market_symbol, BuySellMarketOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/sell/market/{market_symbol}/"
                    urlBuilder_.Append("api/v2/sell/market/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuySellOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sell limit order
        /// </summary>
        /// <remarks>
        /// Open a sell limit order. This call will be executed on the account (Sub or Main), to which the used API key
        /// <br/>is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or price POST parameters | Missing one or both parameters. |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| Minimum order size is 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH | Order value must be at least 10 USD / 10 EUR / 10 GBP / 10 USDT / 10 USDC / 10 PAX / 10 GUSD / 0.0002 BTC / 0.002 ETH |
        /// <br/>| Price is more than 20% below market price. | Order price must not exceed 20% of current price. |
        /// <br/>| You have only 'available_btc' BTC available. Check your account balance for details. | Account has less 'available_btc' than is required to make this order. |
        /// <br/>| Buy if executed price must be lower than sell price. | 'limit_price' must be lower than 'price' parameter. |
        /// <br/>| Both limit_price and daily_order cannot be set. | Only one of those parameters can be set. |
        /// <br/>| Order could not be placed. | Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuySellOrderResponse> OpenLimitSellOrderAsync(string market_symbol, BuySellLimitOrderRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/sell/{market_symbol}/"
                    urlBuilder_.Append("api/v2/sell/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuySellOrderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// All currency pairs tickers
        /// </summary>
        /// <remarks>
        /// Return ticker data for all currency pairs. Passing any GET parameters, will result in your request being rejected.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<TickerWithPairResponse>> GetCurrencyPairTickersAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/ticker/"
                    urlBuilder_.Append("api/v2/ticker/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<TickerWithPairResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Market ticker
        /// </summary>
        /// <remarks>
        /// Return ticker data for the requested currency pair. Passing any GET parameters, will result in your request being rejected.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TickerResponse> GetMarketTickerAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/ticker/{market_symbol}/"
                    urlBuilder_.Append("api/v2/ticker/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TickerResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Hourly  ticker
        /// </summary>
        /// <remarks>
        /// Return hourly ticker data for the requested currency pair. Passing any GET parameters, will result in your request being rejected.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TickerHourResponse> GetHourlyCurrencyPairTickerAsync(string market_symbol, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/ticker_hour/{market_symbol}/"
                    urlBuilder_.Append("api/v2/ticker_hour/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TickerHourResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// TradingPairs
        /// </summary>
        /// <remarks>
        /// View that returns list of all trading pairs.
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<TradingPairsInfoResponseSchema>> GetTradingPairsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/trading-pairs-info/"
                    urlBuilder_.Append("api/v2/trading-pairs-info/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<TradingPairsInfoResponseSchema>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transactions
        /// </summary>
        /// <remarks>
        /// Return transaction data from a given time frame.
        /// </remarks>
        /// <param name="time">The time interval from which we want the transactions to be returned. Possible values are minute, hour (default) or day.</param>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TransactionsResponse> GetTransactionsAsync(string market_symbol, Time? time = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/transactions/{market_symbol}/"
                    urlBuilder_.Append("api/v2/transactions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append('?');
                    if (time != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("time")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(time, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TransactionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer balance from Main to Sub Account
        /// </summary>
        /// <remarks>
        /// Transfers the desired balance from your Main Account to a Sub Account, specified by the subAccount
        /// <br/>parameter. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| You have only 'available' 'currency' available. Check your account balance for details. | Account has less 'available_currency' than is required to make this transfer. |
        /// <br/>| Select a valid choice. X is not one of the available choices. | X is not valid currency. Select a valid currency. |
        /// <br/>| Sub account with identifier "X" does not exist. | Can't find sub account with id X. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TransferToFromMainResponse> TransferFromMainToSubAsync(TransferToFromMainRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/transfer-from-main/"
                    urlBuilder_.Append("api/v2/transfer-from-main/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TransferToFromMainResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer balance from Sub to Main account
        /// </summary>
        /// <remarks>
        /// Transfers the desired balance from a Sub Account to your Main Account.
        /// <br/>Can be called by either the Main Account or a Sub Account, but requires a permission in both cases.
        /// <br/>The subAccount parameter must be provided if the Main Account is initiating the call.
        /// <br/>If a Sub Account is making the call, then it is the target Sub Account for the transfer and no further
        /// <br/>clarification is required.
        /// <br/>In that case, passing this parameter will have no additional effect.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| 'parameter': Enter a number. Use "." as a decimal point. | 'parameter' can only be number. |
        /// <br/>| You have only 'available' 'currency' available. Check your account balance for details. | Account has less 'available_currency' than is required to make this transfer. |
        /// <br/>| Select a valid choice. X is not one of the available choices. | X is not valid currency. Select a valid currency. |
        /// <br/>| Sub account with identifier "X" does not exist. | Can't find sub account with id X. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TransferToFromMainResponse> TransferFromSubToMainAsync(TransferToFromMainRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/transfer-to-main/"
                    urlBuilder_.Append("api/v2/transfer-to-main/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TransferToFromMainResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all contacts
        /// </summary>
        /// <remarks>
        /// Returns all contacts that have been previously created.
        /// <br/>These can then be used to provide the originator or beneficiary details of a Travel Rule message, when
        /// <br/>transferring crypto from/to the platform.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully retrieved the list of contacts.                               |
        /// <br/>| 403           |             | You do not have sufficient permissions to access this endpoint.            |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<ContactSchema>> GetAllContactsAsync(int? per_page = null, int? page = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/travel_rule/contacts/"
                    urlBuilder_.Append("api/v2/travel_rule/contacts/");
                    urlBuilder_.Append('?');
                    if (per_page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("per_page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(per_page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<ContactSchema>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create contact
        /// </summary>
        /// <remarks>
        /// Enables a contact to be created and relevant information to be provided and stored.
        /// <br/>This can then be used to provide the originator or beneficiary details of a Travel Rule message, when
        /// <br/>transferring crypto from/to the platform.
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 201           |             | Successfully created the contact.                                          |
        /// <br/>| 403           |             | You do not have sufficient permissions to access this endpoint.            |
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContactSchema> CreateContactAsync(ContactSchema body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/travel_rule/contacts/"
                    urlBuilder_.Append("api/v2/travel_rule/contacts/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContactSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("Provided data is invalid.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get contact
        /// </summary>
        /// <remarks>
        /// Returns a specific contact that has been previously created.
        /// <br/>This can then be used to provide the originator or beneficiary details of a Travel Rule message, when
        /// <br/>transferring crypto from/to the platform.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully retrieved the contact.                                        |
        /// <br/>| 403           |             | You do not have sufficient permissions to access this endpoint.            |
        /// <br/>| 404           |             | Contact with given contact uuid is not found.                              |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContactSchema> GetContactAsync(string contact_uuid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (contact_uuid == null)
                throw new System.ArgumentNullException("contact_uuid");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/travel_rule/contacts/{contact_uuid}/"
                    urlBuilder_.Append("api/v2/travel_rule/contacts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(contact_uuid, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContactSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("NotFoundError", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// VASP list
        /// </summary>
        /// <remarks>
        /// A list of Virtual Asset Service Providers needed to comply with the Travel Rule.
        /// <br/>These may be needed when transferring cryptocurrency from/to the platform.
        /// <br/>This is required in cases where the originating or destination address of the crypto transfer
        /// <br/>is hosted by a VASP.
        /// <br/>
        /// <br/>**The below table defines the HTTP Status codes that this API may return**
        /// <br/>
        /// <br/>| Response Code | Status Code | Reason                                                                     |
        /// <br/>|---------------|-------------|----------------------------------------------------------------------------|
        /// <br/>| 200           |             | Successfully retrieved the vasp list.                                      |
        /// <br/>| 400           |             | Could not fetch VASP list, service unavailable.                            |
        /// </remarks>
        /// <returns>Get operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response2> VaspListAsync(int? per_page = null, int? page = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/travel_rule/vasps/"
                    urlBuilder_.Append("api/v2/travel_rule/vasps/");
                    urlBuilder_.Append('?');
                    if (per_page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("per_page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(per_page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (page != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("page")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(page, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorSchema>("RequestError", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// User transactions
        /// </summary>
        /// <remarks>
        /// Return user transactions from a given time frame. This call will be executed on the account (Sub
        /// <br/>or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid offset | Offset parameter should be number from 0 to 200000. |
        /// <br/>| Limit too large | Max value of limit parameter is 1000. |
        /// <br/>| Invalid limit | Limit parameter should be number from 1 to 1000. |
        /// <br/>| Invalid sort parameter | Sort parameter can only be 'asc' or 'desc'. |
        /// <br/>| Invalid since_timestamp parameter | since_timestamp can only be digit. |
        /// <br/>| since_timestamp parameter must be higher than .. | Make sure that since_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert since_timestamp parameter | Check the value of since_timestamp parameter. |
        /// <br/>| Invalid until_timestamp parameter | until_timestamp can only be digit. |
        /// <br/>| until_timestamp parameter must be higher than .. | Make sure that until_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert until_timestamp parameter | Check the value of until_timestamp parameter. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<UserTransactionsResponse>> GetUserTransactionsAsync(UserTransactionsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/user_transactions/"
                    urlBuilder_.Append("api/v2/user_transactions/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<UserTransactionsResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// User transactions for market
        /// </summary>
        /// <remarks>
        /// Return user transactions for a market from a given time frame. This call will be executed on
        /// <br/>the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid offset | Offset parameter should be number from 0 to 200000. |
        /// <br/>| Limit too large | Max value of limit parameter is 1000. |
        /// <br/>| Invalid limit | Limit parameter should be number from 1 to 1000. |
        /// <br/>| Invalid sort parameter | Sort parameter can only be 'asc' or 'desc'. |
        /// <br/>| Invalid since_timestamp parameter | since_timestamp can only be digit. |
        /// <br/>| since_timestamp parameter must be higher than .. | Make sure that since_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert since_timestamp parameter | Check the value of since_timestamp parameter. |
        /// <br/>| Invalid until_timestamp parameter | until_timestamp can only be digit. |
        /// <br/>| until_timestamp parameter must be higher than .. | Make sure that until_timestamp is less than 30 days in the past. |
        /// <br/>| Failed to convert until_timestamp parameter | Check the value of until_timestamp parameter. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.List<UserTransactionsResponse>> GetUserTransactionsForMarketAsync(string market_symbol, UserTransactionsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (market_symbol == null)
                throw new System.ArgumentNullException("market_symbol");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/user_transactions/{market_symbol}/"
                    urlBuilder_.Append("api/v2/user_transactions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(market_symbol, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.List<UserTransactionsResponse>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Websockets token
        /// </summary>
        /// <remarks>
        /// Generates token required for subscribing to private WebSocket channels.
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WebsocketsTokenResponse> GetWebsocketTokenAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/websockets_token/"
                    urlBuilder_.Append("api/v2/websockets_token/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WebsocketsTokenResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Withdrawal requests
        /// </summary>
        /// <remarks>
        /// Return user's withdrawal requests. This call will be executed on the account (Sub or Main), to which the
        /// <br/>used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Invalid timedelta | Timedelta needs to have only numeric characters. |
        /// <br/>| Timedelta too large | Timedelta too large. |
        /// <br/>| Invalid offset | Offset needs to be numeric characters between 0 and 200000. |
        /// <br/>| Invalid limit | Limit needs to be numeric characters between 1 and 1000. |
        /// <br/>| Invalid id | Id needs to have only numeric characters. |
        /// <br/>| Both limit and offset must be present | Both limit and offset must be present. |
        /// <br/>| Too many parameters | Pick one or combination of parameters and run again. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WithdrawalRequestsResponse> GetWithdrawalRequestsAsync(WithdrawalRequestsRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/withdrawal-requests/"
                    urlBuilder_.Append("api/v2/withdrawal-requests/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WithdrawalRequestsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cancel bank or crypto withdrawal
        /// </summary>
        /// <remarks>
        /// Cancels a bank or crypto withdrawal request. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Cancelling bank withdrawals with sub account API keys is not supported. | This API endpoint can only be utilized by your main account. |
        /// <br/>| Missing parameters: [...] | Parameters stated in the list ([...]) are required for this call. |
        /// <br/>| No active bank withdrawal with id=X found. | Could not find any active bank withdrawal with the id X. Will return the same response for already cancelled withdrawal requests. |
        /// <br/>| Cannot cancel a withdrawal in process (id=X). | The bank withdrawal request with id=X is currently being processed and cannot be cancelled. |
        /// <br/>| Your withdrawals are currently disabled | No bank withdrawals can be canceled at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CancelBankWithdrawalResponse> CancelWithdrawalAsync(CancelBankOrCryptoWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/withdrawal/cancel/"
                    urlBuilder_.Append("api/v2/withdrawal/cancel/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CancelBankWithdrawalResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Open bank withdrawal
        /// </summary>
        /// <remarks>
        /// Opens a bank withdrawal request (SEPA or international). Withdrawal requests opened via API are
        /// <br/>automatically confirmed (no confirmation e-mail will be sent), but are processed just like withdrawals
        /// <br/>opened through the platform's interface. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Opening bank withdrawals with sub account API keys is not supported. | This API endpoint can only be utilized by your main account. |
        /// <br/>| 'X': ['This field is required.'] | Parameter X is required for this call. |
        /// <br/>| 'X': ['Select a valid choice. Y is not one of the available choices.'] | Y is not a valid value for parameter X. |
        /// <br/>| Bank withdrawals temporarily disabled. | No new bank withdrawals can be opened at this time. |
        /// <br/>| Unsupported withdrawal type (must be either SEPA or international). | When opening bank withdrawals, you must specify one of the two supported types: SEPA or international. |
        /// <br/>| When opening bank withdrawals, you must specify one of the two supported types: SEPA or international. | To open this withdrawal, your balance must have at least 'amount' of target currency available. |
        /// <br/>| 'X': ['Enter a number. Use "." as a decimal point.'] | Parameter X can only be a decimal number. |
        /// <br/>| Your withdrawals are currently disabled | No new withdrawals can be opened at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OpenBankWithdrawalResponse> RequestFiatWithdrawalAsync(OpenBankWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/withdrawal/open/"
                    urlBuilder_.Append("api/v2/withdrawal/open/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OpenBankWithdrawalResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fiat withdrawal status
        /// </summary>
        /// <remarks>
        /// Checks the status of a fiat withdrawal request. This call can only be performed by your Main Account.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Performing bank withdrawal status checks with sub account API keys is not supported. | This API endpoint can only be utilized by your main account. |
        /// <br/>| Missing parameters: [...]. | Parameters stated in the list ([...]) are required for this call. |
        /// <br/>| No bank withdrawal with id=X found. | Could not find any bank withdrawal with the id X. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BankWithdrawalStatusResponse> GetFiatWithdrawalStatusAsync(BankWithdrawalStatusRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/withdrawal/status/"
                    urlBuilder_.Append("api/v2/withdrawal/status/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BankWithdrawalStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crypto deposit address
        /// </summary>
        /// <remarks>
        /// This call will be executed on the account (Sub or Main), to which the used API key is bound to.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| Your deposits are currently disabled | No new deposits can be made at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>| Invalid network selection | The selected network is not supported for 'currency'. Please select a compatible network for it. |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DepositAddressResponse> GetCryptoDepositAddressAsync(string currency, DepositAddressRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (currency == null)
                throw new System.ArgumentNullException("currency");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/{currency}_address/"
                    urlBuilder_.Append("api/v2/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(currency, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("_address/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DepositAddressResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crypto withdrawal
        /// </summary>
        /// <remarks>
        /// Request a crypto withdrawal.
        /// <br/>
        /// <br/>&lt;details&gt;
        /// <br/>&lt;summary style='cursor: pointer'&gt;&lt;strong&gt;Possible errors&lt;/strong&gt;&lt;/summary&gt;
        /// <br/>
        /// <br/>| Reason | Action |
        /// <br/>| ----------- | ----------- |
        /// <br/>| Missing amount and/or address POST parameters | One or both parameters missing. |
        /// <br/>| User not verified | Your account needs to be verified before you can use this endpoint. |
        /// <br/>| 'crypto_currency' withdrawals are currently unavailable for your account | Contact support for additional information. |
        /// <br/>| Not allowed to withdraw to specified 'crypto_currency' address | API key is set for withdrawing to another 'crypto_currency' address. |
        /// <br/>| Enter a number. Use "." as a decimal point | Amount parameter can only be number. |
        /// <br/>| You have only 'available' 'crypto_currency' available. Check your account balance for details | Account has less available 'crypto_currency' than are required to make this withdrawal. |
        /// <br/>| Your withdrawals are currently disabled | No new withdrawals can be opened at this time. If a URL is provided you can follow it to resolve any issues which might be causing this. |
        /// <br/>| Ensure this value is greater than or equal to 'minimum_withdrawal_amount' | Minimum withdrawal amount is 'minimum_withdrawal_amount'. |
        /// <br/>| Ensure this value has at least 'minimum_address_length' characters (it has x). Ensure this value has at most 'maximum_address_length' characters (it has x). | Address parameter must be between 'minimum_address_length' and 'maximum_address_length' characters long. |
        /// <br/>| Invalid network selection | The selected network is not supported for 'currency'. Please select a compatible network for it. |
        /// <br/>| Contact does not exist | Review and validate the contact_uuid to ensure it matches an existing contact, you may also create contacts at /v2/travel_rule/contacts endpoint |
        /// <br/>| Vasp does not exist | Verify that the vasp_uuid exists within the /v2/travel_rule/vasps endpoint. |
        /// <br/>| contact_uuid: You must set this field because contact_thirdparty=True | contact_uuid must be provided if withdrawing to a third party |
        /// <br/>&lt;/details&gt;
        /// </remarks>
        /// <returns>Post operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CryptoWithdrawalResponse> RequestCryptoWithdrawalAsync(string currency, CryptoWithdrawalRequest body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (currency == null)
                throw new System.ArgumentNullException("currency");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, _settings.Value);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v2/{currency}_withdrawal/"
                    urlBuilder_.Append("api/v2/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(currency, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("_withdrawal/");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CryptoWithdrawalResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccountBalancesResponse
    {
        /// <summary>
        /// Available balance for trading.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("available")]
        public string Available { get; set; }

        /// <summary>
        /// Currency name.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// Reserved balance for trading.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("reserved")]
        public string Reserved { get; set; }

        /// <summary>
        /// Total balance on exchange.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("total")]
        public string Total { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static AccountBalancesResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<AccountBalancesResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BankWithdrawalStatusRequest
    {
        /// <summary>
        /// ID of the withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static BankWithdrawalStatusRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<BankWithdrawalStatusRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BankWithdrawalStatusResponse
    {
        /// <summary>
        /// Status of the withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static BankWithdrawalStatusResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<BankWithdrawalStatusResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuyInstantOrderRequest
    {
        /// <summary>
        /// Amount in counter currency (Example: For BTC/USD pair, amount is quoted in USD)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// Client order ID set by the client for internal reference. It should be unique, but there are no additional constraints or checks guaranteed on the field by Bitstamp.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static BuyInstantOrderRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<BuyInstantOrderRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuySellLimitOrderRequest
    {
        /// <summary>
        /// Amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        [System.ComponentModel.DataAnnotations.Range(0.00000001D, 92233720368D)]
        public double Amount { get; set; }

        /// <summary>
        /// Price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        [System.ComponentModel.DataAnnotations.Range(0.00000001D, 92233720368D)]
        public double Price { get; set; }

        /// <summary>
        /// If the order gets executed, a new sell order will be placed, with "limit_price" as its price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("limit_price")]
        [System.ComponentModel.DataAnnotations.Range(0.00000001D, 92233720368D)]
        public double? Limit_price { get; set; }

        /// <summary>
        /// Opens buy limit order which will be canceled at 0:00 UTC unless it already has been executed.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("daily_order")]
        public bool? Daily_order { get; set; }

        /// <summary>
        /// An Immediate-Or-Cancel (IOC) order is an order that must be executed immediately. Any portion of an IOC order that cannot be filled immediately will be cancelled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ioc_order")]
        public bool? Ioc_order { get; set; }

        /// <summary>
        /// A Fill-Or-Kill (FOK) order is an order that must be executed immediately in its entirety. If the order cannot be immediately executed in its entirety, it will be cancelled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("fok_order")]
        public bool? Fok_order { get; set; }

        /// <summary>
        /// A Maker-Or-Cancel (MOC) order is an order that ensures it is not fully or partially filled when placed. In case it would be, the order is cancelled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("moc_order")]
        public bool? Moc_order { get; set; }

        /// <summary>
        /// A Good-Till-Date (GTD) lets you select an expiration time up until which the order will be open. Note that all GTD orders are cancelled at 00:00:00 UTC.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("gtd_order")]
        public bool? Gtd_order { get; set; }

        /// <summary>
        /// Unix timestamp in milliseconds. Required in case of GTD order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("expire_time")]
        public int? Expire_time { get; set; }

        /// <summary>
        /// Client order ID set by the client for internal reference. It should be unique, but there are no additional constraints or checks guaranteed on the field by Bitstamp.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static BuySellLimitOrderRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<BuySellLimitOrderRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuySellMarketOrderRequest
    {
        /// <summary>
        /// Amount in base currency (Example: For BTC/USD pair, amount is quoted in BTC)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// Client order ID set by the client for internal reference. It should be unique, but there are no additional constraints or checks guaranteed on the field by Bitstamp.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static BuySellMarketOrderRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<BuySellMarketOrderRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuySellOrderResponse
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Market formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public System.DateTimeOffset? Datetime { get; set; }

        /// <summary>
        /// 0 (buy) or 1 (sell).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public string Price { get; set; }

        /// <summary>
        /// Amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Client order ID sent with request. Only returned if parameter was used in request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static BuySellOrderResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<BuySellOrderResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelAllOrdersResponse
    {

        [System.Text.Json.Serialization.JsonPropertyName("canceled")]
        public System.Collections.Generic.ICollection<Order> Canceled { get; set; }

        /// <summary>
        /// "true" if all orders were successfully canceled and "false" otherwise
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("success")]
        public bool? Success { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CancelAllOrdersResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CancelAllOrdersResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelBankOrCryptoWithdrawalRequest
    {
        /// <summary>
        /// ID of the withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CancelBankOrCryptoWithdrawalRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CancelBankOrCryptoWithdrawalRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelBankWithdrawalResponse
    {
        /// <summary>
        /// Account currency (balance currency from which the withdrawal was requested) of the cancelled withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("account_currency")]
        public string Account_currency { get; set; }

        /// <summary>
        /// Amount of the cancelled withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double? Amount { get; set; }

        /// <summary>
        /// Currency of the cancelled withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// ID of the cancelled withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The type of the cancelled withdrawal request.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CancelBankWithdrawalResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CancelBankWithdrawalResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelOrderRequest
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CancelOrderRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CancelOrderRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CancelOrderResponse
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        /// <summary>
        /// Order amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double? Amount { get; set; }

        /// <summary>
        /// Order price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public double? Price { get; set; }

        /// <summary>
        /// Order type.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public int? Type { get; set; }

        /// <summary>
        /// Market formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CancelOrderResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CancelOrderResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContactSchema
    {
        /// <summary>
        /// Additional info if the beneficiary is a corporate client
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("corporate_info")]
        public CorporateInfo Corporate_info { get; set; }

        /// <summary>
        /// Alias for your internal usage of the contact
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("description")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Id of the contact
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        /// <summary>
        /// Additional info if the beneficiary is a retail client
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("retail_info")]
        public RetailInfo Retail_info { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static ContactSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<ContactSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CorporateInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Name of the company
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("company_name")]
        public string Company_name { get; set; }

        /// <summary>
        /// ISO 3166-1 alpha 2 country code
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("country")]
        public string Country { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CorporateInfo FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CorporateInfo>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoTransaction
    {
        /// <summary>
        /// Amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double? Amount { get; set; }

        /// <summary>
        /// Currency.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public int? Datetime { get; set; }

        /// <summary>
        /// Destination address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("destinationAddress")]
        public string DestinationAddress { get; set; }

        /// <summary>
        /// Cryptocurrency network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("network")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CryptoTransactionNetwork? Network { get; set; }

        /// <summary>
        /// Transaction hash.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("txid")]
        public string Txid { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CryptoTransaction FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CryptoTransaction>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoTransactionsRequest
    {
        /// <summary>
        /// True - shows also ripple IOU transactions.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("include_ious")]
        public bool? Include_ious { get; set; }

        /// <summary>
        /// Limit result to that many transactions (default: 100; maximum: 1000).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("limit")]
        public int? Limit { get; set; }

        /// <summary>
        /// Skip that many transactions before returning results (default: 0, maximum: 200000).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("offset")]
        public int? Offset { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CryptoTransactionsRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CryptoTransactionsRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoTransactionsResponse
    {
        /// <summary>
        /// Deposits.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("deposits")]
        public System.Collections.Generic.ICollection<CryptoTransaction> Deposits { get; set; }

        /// <summary>
        /// Ripple IOU transactions.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ripple_iou_transactions")]
        public System.Collections.Generic.ICollection<CryptoTransaction> Ripple_iou_transactions { get; set; }

        /// <summary>
        /// Withdrawals.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("withdrawals")]
        public System.Collections.Generic.ICollection<CryptoTransaction> Withdrawals { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CryptoTransactionsResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CryptoTransactionsResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoWithdrawalRequest
    {
        /// <summary>
        /// Cryptocurrency address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>
        /// Cryptocurrency amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// If the address you are withdrawing to is in your name (regardless of if this is a hosted or unhosted wallet), this should be set to False. If you are withdrawing to a third party, set it to True
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("contact_thirdparty")]
        public bool? Contact_thirdparty { get; set; }

        /// <summary>
        /// If setting the contact_thirdparty field to True, you need to provide the UUID of the contact from the /v2/travel_rule/contacts/ endpoint
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("contact_uuid")]
        public System.Guid? Contact_uuid { get; set; }

        /// <summary>
        /// Address destination tag - applicable to: XRP.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("destination_tag")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Destination_tag { get; set; }

        /// <summary>
        /// Address memo id - applicable to: XLM, HBAR, GYEN, VCHF, VEUR, ZUSD.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("memo_id")]
        public string Memo_id { get; set; }

        /// <summary>
        /// Cryptocurrency network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("network")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CryptoWithdrawalRequestNetwork? Network { get; set; }

        /// <summary>
        /// Address transfer id - applicable to: CSPR.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("transfer_id")]
        public int? Transfer_id { get; set; }

        /// <summary>
        /// When withdrawing to a hosted wallet by a Virtual Asset Services Provider, provide the UUID from the /v2/travel_rule/vasps/ endpoint
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("vasp_uuid")]
        public System.Guid? Vasp_uuid { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CryptoWithdrawalRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CryptoWithdrawalRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CryptoWithdrawalResponse
    {
        /// <summary>
        /// Withdrawal ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CryptoWithdrawalResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CryptoWithdrawalResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CurrencySchema
    {

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CurrencySchemaType Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("symbol")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Symbol { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("decimals")]
        [System.ComponentModel.DataAnnotations.Range(2, int.MaxValue)]
        public int Decimals { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("logo")]
        public string Logo { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("available_supply")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Available_supply { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("deposit")]
        public string Deposit { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("withdrawal")]
        public string Withdrawal { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static CurrencySchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<CurrencySchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DepositAddressRequest
    {
        /// <summary>
        /// Cryptocurrency network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("network")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public DepositAddressRequestNetwork? Network { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static DepositAddressRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<DepositAddressRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DepositAddressResponse
    {
        /// <summary>
        /// Address for requested currency.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Destination tag in case of currency XRP or Ripple, otherwise not present.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("destination_tag")]
        public int? Destination_tag { get; set; }

        /// <summary>
        /// Memo ID in case of network HBAR or XLM, otherwise not present.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("memo_id")]
        public string Memo_id { get; set; }

        /// <summary>
        /// Transfer ID in case of network CSPR, otherwise not present.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("transfer_id")]
        public int? Transfer_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static DepositAddressResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<DepositAddressResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EarnSubscriptionSchema
    {
        /// <summary>
        /// Amount to subscribe or unsubscribe with.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// Currency
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }

        /// <summary>
        /// Type of Earn term
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("earn_term")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionSchemaEarn_term Earn_term { get; set; }

        /// <summary>
        /// Type of Earn product
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("earn_type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionSchemaEarn_type Earn_type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static EarnSubscriptionSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<EarnSubscriptionSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EarnSubscriptionSettingSchema
    {
        /// <summary>
        /// Currency
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }

        /// <summary>
        /// Type of Earn product
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("earn_type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionSettingSchemaEarn_type Earn_type { get; set; }

        /// <summary>
        /// Type of setting action.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("setting")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionSettingSchemaSetting Setting { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static EarnSubscriptionSettingSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<EarnSubscriptionSettingSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EarnSubscriptionsSchema
    {
        /// <summary>
        /// Expected time until earn option starts to earn rewards
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("activation_period")]
        public string Activation_period { get; set; }

        /// <summary>
        /// Amount on which you are earning interest
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double? Amount { get; set; }

        /// <summary>
        /// Amount that has been earned
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount_earned")]
        public double? Amount_earned { get; set; }

        /// <summary>
        /// Amount on which you are earning interest that is available to withdraw from Earn
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("available_amount")]
        public double? Available_amount { get; set; }

        /// <summary>
        /// Currency
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// Period in which the rewards are distributed
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("distribution_period")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionsSchemaDistribution_period? Distribution_period { get; set; }

        /// <summary>
        /// Estimated annual yield
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("estimated_annual_yield")]
        public double? Estimated_annual_yield { get; set; }

        /// <summary>
        /// Minimum amount for subscription
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("minimum_subscription_amount")]
        public double? Minimum_subscription_amount { get; set; }

        /// <summary>
        /// Type of Earn term
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("term")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionsSchemaTerm? Term { get; set; }

        /// <summary>
        /// Type of Earn product
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnSubscriptionsSchemaType? Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static EarnSubscriptionsSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<EarnSubscriptionsSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EarnTransactionSchema
    {
        /// <summary>
        /// Amount in base currency
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double? Amount { get; set; }

        /// <summary>
        /// Currency
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// Date and time of earn history event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public System.DateTimeOffset? Datetime { get; set; }

        /// <summary>
        /// Currency in which value is calculated
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("quote_currency")]
        public string Quote_currency { get; set; }

        /// <summary>
        /// Status of earn history event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnTransactionSchemaStatus? Status { get; set; }

        /// <summary>
        /// Type of earn history event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EarnTransactionSchemaType? Type { get; set; }

        /// <summary>
        /// Amount in quote currency
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("value")]
        public double? Value { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static EarnTransactionSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<EarnTransactionSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EmptySchema
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static EmptySchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<EmptySchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorResponse
    {
        /// <summary>
        /// Error reason.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("reason")]
        public string Reason { get; set; }

        /// <summary>
        /// "error"
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static ErrorResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<ErrorResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorSchema
    {

        [System.Text.Json.Serialization.JsonPropertyName("code")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Code { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("field")]
        public string Field { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("message")]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static ErrorSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<ErrorSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EurUsdConversionRateResponse
    {
        /// <summary>
        /// Buy conversion rate.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("buy")]
        public string Buy { get; set; }

        /// <summary>
        /// Sell conversion rate.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("sell")]
        public string Sell { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static EurUsdConversionRateResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<EurUsdConversionRateResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Fee
    {
        /// <summary>
        /// Fee for maker of the market.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("maker")]
        public string Maker { get; set; }

        /// <summary>
        /// Fee for taker of the market.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("taker")]
        public string Taker { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static Fee FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<Fee>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeeTradingResponse
    {
        /// <summary>
        /// Currency pair name (deprecated).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency_pair")]
        public string Currency_pair { get; set; }

        /// <summary>
        /// Dictionary of maker and taker fees.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("fees")]
        public System.Collections.Generic.ICollection<Fee> Fees { get; set; }

        /// <summary>
        /// Market for fees.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static FeeTradingResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<FeeTradingResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeeWithdrawalRequest
    {
        /// <summary>
        /// Cryptocurrency network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("network")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public FeeWithdrawalRequestNetwork? Network { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static FeeWithdrawalRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<FeeWithdrawalRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeeWithdrawalResponse
    {
        /// <summary>
        /// Currency name.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// Customer withdrawal fee.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("fee")]
        public string Fee { get; set; }

        /// <summary>
        /// Cryptocurrency network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("network")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public FeeWithdrawalResponseNetwork? Network { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static FeeWithdrawalResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<FeeWithdrawalResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstantConvertAddressInfoRequest
    {
        /// <summary>
        /// Shows transactions for specific instant convert address or for all users instant convert addresses.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static InstantConvertAddressInfoRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<InstantConvertAddressInfoRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstantConvertAddressInfoResponse
    {
        /// <summary>
        /// Address set for automatic conversion
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Address set for automatic conversion.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency_pair")]
        public string Currency_pair { get; set; }

        /// <summary>
        /// List of transactions.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("transactions")]
        public System.Collections.Generic.ICollection<Transaction> Transactions { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static InstantConvertAddressInfoResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<InstantConvertAddressInfoResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NewInstantConvertAddressRequest
    {
        /// <summary>
        /// 	Address format. Can be either "P2SHP2WSH" or "BECH32".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address_format")]
        public string Address_format { get; set; }

        /// <summary>
        /// Deposited BTCs will be automatically converted to liquidation_currency.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("liquidation_currency")]
        public string Liquidation_currency { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static NewInstantConvertAddressRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<NewInstantConvertAddressRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NewInstantConvertAddressResponse
    {
        /// <summary>
        /// Address set for automatic conversion.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static NewInstantConvertAddressResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<NewInstantConvertAddressResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OHLCData
    {
        /// <summary>
        /// Unix timestamp date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public string Timestamp { get; set; }

        /// <summary>
        /// Opening price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("open")]
        public string Open { get; set; }

        /// <summary>
        /// Price high.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("high")]
        public string High { get; set; }

        /// <summary>
        /// Price low.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("low")]
        public string Low { get; set; }

        /// <summary>
        /// Closing price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("close")]
        public string Close { get; set; }

        /// <summary>
        /// Volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("volume")]
        public string Volume { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OHLCData FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OHLCData>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OHLCDataResponseSchema
    {
        /// <summary>
        /// Trading pair.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("pair")]
        public string Pair { get; set; }

        /// <summary>
        /// OHLC data.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ohlc")]
        public System.Collections.Generic.ICollection<OHLCData> Ohlc { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OHLCDataResponseSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OHLCDataResponseSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenBankWithdrawalRequest
    {
        /// <summary>
        /// The balance from which you wish to withdraw. Can be either "USD", "EUR" or "GBP".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("account_currency")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Account_currency { get; set; }

        /// <summary>
        /// User or company address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>
        /// The amount to withdraw.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Amount { get; set; }

        /// <summary>
        /// Target bank address (international withdrawals only).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bank_address")]
        public string Bank_address { get; set; }

        /// <summary>
        /// Target bank city (international withdrawals only).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bank_city")]
        public string Bank_city { get; set; }

        /// <summary>
        /// Target bank country. Country codes must be in accordance with the ISO 3166-1 standard (use two character Alpha-2 codes). Disclaimer: Not all country choices listed at this reference URL are supported. For a detailed list please refer to our platform's withdrawal interfaces (international withdrawals only).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bank_country")]
        public string Bank_country { get; set; }

        /// <summary>
        /// Target bank name (international withdrawals only).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bank_name")]
        public string Bank_name { get; set; }

        /// <summary>
        /// Target bank postal code (international withdrawals only).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bank_postal_code")]
        public string Bank_postal_code { get; set; }

        /// <summary>
        /// The target bank BIC.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bic")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Bic { get; set; }

        /// <summary>
        /// User or company city.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("city")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string City { get; set; }

        /// <summary>
        /// Withdrawal comment.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("comment")]
        public string Comment { get; set; }

        /// <summary>
        /// User or company country. Country codes must be in accordance with the ISO 3166-1 standard (use two character Alpha-2 codes). Disclaimer: Not all country choices listed at this reference URL are supported. For a detailed list please refer to our platform's withdrawal interfaces.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("country")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Country { get; set; }

        /// <summary>
        /// The currency in which the funds should be withdrawn (may involve conversion fees). Currency codes must be in accordance with the ISO 4217 standard. Disclaimer: Not all currency choices listed at this reference URL are supported. For a detailed list please refer to our platform's withdrawal interfaces. (international withdrawals only)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// User or company IBAN.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("iban")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Iban { get; set; }

        /// <summary>
        /// Full user or company name.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// User or company postal code.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("postal_code")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Postal_code { get; set; }

        /// <summary>
        /// Type of the withdrawal request ("sepa" or "international").
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OpenBankWithdrawalRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OpenBankWithdrawalRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenBankWithdrawalResponse
    {
        /// <summary>
        /// Withdrawal ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("withdrawal_id")]
        public int? Withdrawal_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OpenBankWithdrawalResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OpenBankWithdrawalResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenOrdersAllResponse
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public string Datetime { get; set; }

        /// <summary>
        /// Order type: 0 - buy; 1 - sell.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public string Price { get; set; }

        /// <summary>
        /// Remaining amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Initial amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount_at_create")]
        public string Amount_at_create { get; set; }

        /// <summary>
        /// Currency Pair (deprecated).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency_pair")]
        public string Currency_pair { get; set; }

        /// <summary>
        /// Market formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        /// <summary>
        /// Limit price. (Only returned if limit order was placed with limit_price parameter.)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("limit_price")]
        public string Limit_price { get; set; }

        /// <summary>
        /// Client order id. (Only returned if order was placed with client order id parameter.)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OpenOrdersAllResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OpenOrdersAllResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenOrdersPairResponse
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public string Datetime { get; set; }

        /// <summary>
        /// Order type: 0 - buy; 1 - sell.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public string Price { get; set; }

        /// <summary>
        /// Remaining amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Initial amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount_at_create")]
        public string Amount_at_create { get; set; }

        /// <summary>
        /// Market formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        /// <summary>
        /// Limit price. (Only returned if limit order was placed with limit_price parameter.)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("limit_price")]
        public string Limit_price { get; set; }

        /// <summary>
        /// Client order id. (Only returned if order was placed with client order id parameter.)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OpenOrdersPairResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OpenOrdersPairResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Order
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        /// <summary>
        /// Order amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double? Amount { get; set; }

        /// <summary>
        /// Order price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public double? Price { get; set; }

        /// <summary>
        /// Order type.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public int? Type { get; set; }

        /// <summary>
        /// Currency pair formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency_pair")]
        public string Currency_pair { get; set; }

        /// <summary>
        /// Market formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static Order FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<Order>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OrderBookResponse
    {
        /// <summary>
        /// List of sell orders.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("asks")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Asks { get; set; }

        /// <summary>
        /// List of buy orders.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bids")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Bids { get; set; }

        /// <summary>
        /// Unix timestamp date and time in microseconds.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("microtimestamp")]
        public string Microtimestamp { get; set; }

        /// <summary>
        /// Unix timestamp date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public string Timestamp { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OrderBookResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OrderBookResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OrderStatusRequest
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// (Optional) Client order id. (Can only be used if order was placed with client order id parameter.).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        /// <summary>
        /// (Optional) Omits list of transactions for order ID. Possible value: True
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("omit_transactions")]
        public string Omit_transactions { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OrderStatusRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OrderStatusRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OrderStatusResponse
    {
        /// <summary>
        /// Order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public string Datetime { get; set; }

        /// <summary>
        /// Type: 0 - buy; 1 - sell.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Open, Finished, Expired or Canceled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// Market formatted as "BTC/USD".
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("market")]
        public string Market { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("transactions")]
        public System.Collections.Generic.ICollection<OrderTransaction> Transactions { get; set; }

        /// <summary>
        /// Amount remaining.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount_remaining")]
        public string Amount_remaining { get; set; }

        /// <summary>
        /// Client order id. (Only returned if order was placed with client order id parameter.).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OrderStatusResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OrderStatusResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OrderTransaction
    {
        /// <summary>
        /// Transaction ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("tid")]
        public int? Tid { get; set; }

        /// <summary>
        /// Price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public string Price { get; set; }

        /// <summary>
        /// {from_currency} amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("from_currency")]
        public string From_currency { get; set; }

        /// <summary>
        /// {to_currency} amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("to_currency")]
        public string To_currency { get; set; }

        /// <summary>
        /// Transaction fee.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("fee")]
        public string Fee { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public string Datetime { get; set; }

        /// <summary>
        /// Transaction type: 0 - deposit; 1 - withdrawal; 2 - market trade.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public int? Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static OrderTransaction FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<OrderTransaction>(data, options);

        }

    }

    /// <summary>
    ///         Pagination schema for response.
    /// <br/>        Args:
    /// <br/>            page: (int) page number
    /// <br/>            size: (int) page full size
    /// <br/>            count:  (int) number of items in current page
    /// <br/>        
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PaginationSchema
    {

        [System.Text.Json.Serialization.JsonPropertyName("page")]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? Page { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("size")]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? Size { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("count")]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? Count { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static PaginationSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<PaginationSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetailInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("city")]
        public string City { get; set; }

        /// <summary>
        /// ISO 3166-1 alpha 2 country code
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("country")]
        public string Country { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("date_of_birth")]
        [System.Text.Json.Serialization.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset? Date_of_birth { get; set; }

        /// <summary>
        /// First name of the contact
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("first_name")]
        public string First_name { get; set; }

        /// <summary>
        /// Last name of the contact
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("last_name")]
        public string Last_name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("street_and_house_number")]
        public string Street_and_house_number { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("zip")]
        public string Zip { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static RetailInfo FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<RetailInfo>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RevokedAPIKeySchema
    {
        /// <summary>
        /// API keys that were revoked.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("revoked_api_keys")]
        public System.Collections.Generic.ICollection<string> Revoked_api_keys { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static RevokedAPIKeySchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<RevokedAPIKeySchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RippleIOUDepositAddressResponse
    {
        /// <summary>
        /// Ripple address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Destination tag.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("destination_tag")]
        public int? Destination_tag { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static RippleIOUDepositAddressResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<RippleIOUDepositAddressResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RippleIOUWithdrawalRequest
    {
        /// <summary>
        /// Ripple address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>
        /// Currency amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// Currency to withdraw.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static RippleIOUWithdrawalRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<RippleIOUWithdrawalRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RippleIOUWithdrawalResponse
    {
        /// <summary>
        /// Withdrawal ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static RippleIOUWithdrawalResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<RippleIOUWithdrawalResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SellInstantOrderRequest
    {
        /// <summary>
        /// Amount in base currency (Example: For BTC/USD pair, amount is quoted in BTC)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// (Optional) Instant sell orders allow you to sell an amount of the base currency determined by the value of it in the counter-currency. Amount_in_counter sets the amount parameter to refer to the counter currency instead of the base currency of the selected trading pair. Possible value: True
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount_in_counter")]
        public bool? Amount_in_counter { get; set; }

        /// <summary>
        /// Client order ID set by the client for internal reference. It should be unique, but there are no additional constraints or checks guaranteed on the field by Bitstamp.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("client_order_id")]
        public string Client_order_id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static SellInstantOrderRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<SellInstantOrderRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SimpleErrorResponse
    {
        /// <summary>
        /// The reason for the error.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public string Error { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static SimpleErrorResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<SimpleErrorResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TickerHourResponse
    {
        /// <summary>
        /// Lowest sell order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ask")]
        public string Ask { get; set; }

        /// <summary>
        /// Highest buy order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bid")]
        public string Bid { get; set; }

        /// <summary>
        /// Last hour price high.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("high")]
        public string High { get; set; }

        /// <summary>
        /// Last price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("last")]
        public string Last { get; set; }

        /// <summary>
        /// Last hour price low.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("low")]
        public string Low { get; set; }

        /// <summary>
        /// First price of the hour.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("open")]
        public string Open { get; set; }

        /// <summary>
        /// Ticker side: 0 - buy; 1 - sell.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// Unix timestamp date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public string Timestamp { get; set; }

        /// <summary>
        /// Last hour volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("volume")]
        public string Volume { get; set; }

        /// <summary>
        /// Last hour volume weighted average price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("vwap")]
        public string Vwap { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TickerHourResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TickerHourResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TickerResponse
    {
        /// <summary>
        /// Lowest sell order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ask")]
        public string Ask { get; set; }

        /// <summary>
        /// Highest buy order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bid")]
        public string Bid { get; set; }

        /// <summary>
        /// Last 24 hours price high.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("high")]
        public string High { get; set; }

        /// <summary>
        /// Last price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("last")]
        public string Last { get; set; }

        /// <summary>
        /// Last 24 hours price low.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("low")]
        public string Low { get; set; }

        /// <summary>
        /// First price of the day.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("open")]
        public string Open { get; set; }

        /// <summary>
        /// 24 hours time delta transaction price
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("open_24")]
        public string Open_24 { get; set; }

        /// <summary>
        /// 24 hours price change percent
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("percent_change_24")]
        public string Percent_change_24 { get; set; }

        /// <summary>
        /// Ticker side: 0 - buy; 1 - sell.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// Unix timestamp date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public string Timestamp { get; set; }

        /// <summary>
        /// Last 24 hours volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("volume")]
        public string Volume { get; set; }

        /// <summary>
        /// Last 24 hours volume weighted average price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("vwap")]
        public string Vwap { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TickerResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TickerResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TickerWithPairResponse
    {
        /// <summary>
        /// Lowest sell order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ask")]
        public string Ask { get; set; }

        /// <summary>
        /// Highest buy order.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("bid")]
        public string Bid { get; set; }

        /// <summary>
        /// Last 24 hours price high.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("high")]
        public string High { get; set; }

        /// <summary>
        /// Last price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("last")]
        public string Last { get; set; }

        /// <summary>
        /// Last 24 hours price low.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("low")]
        public string Low { get; set; }

        /// <summary>
        /// First price of the day.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("open")]
        public string Open { get; set; }

        /// <summary>
        /// 24 hours time delta transaction price
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("open_24")]
        public string Open_24 { get; set; }

        /// <summary>
        /// Currency pair name
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("pair")]
        public string Pair { get; set; }

        /// <summary>
        /// 24 hours price change percent
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("percent_change_24")]
        public string Percent_change_24 { get; set; }

        /// <summary>
        /// Ticker side: 0 - buy; 1 - sell.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("side")]
        public string Side { get; set; }

        /// <summary>
        /// Unix timestamp date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public string Timestamp { get; set; }

        /// <summary>
        /// Last 24 hours volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("volume")]
        public string Volume { get; set; }

        /// <summary>
        /// Last 24 hours volume weighted average price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("vwap")]
        public string Vwap { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TickerWithPairResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TickerWithPairResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Trade
    {
        /// <summary>
        /// BTC amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("btc_amount")]
        public string Btc_amount { get; set; }

        /// <summary>
        /// Exchange rate.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("exchange_rate")]
        public string Exchange_rate { get; set; }

        /// <summary>
        /// Fees.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("fees")]
        public string Fees { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static Trade FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<Trade>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TradingPair
    {
        /// <summary>
        /// Trading pair.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// URL symbol of trading pair.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("url_symbol")]
        public string Url_symbol { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TradingPair FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TradingPair>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TradingPairsInfoResponseSchema
    {
        /// <summary>
        /// Trading pair.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// URL symbol of trading pair.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("url_symbol")]
        public string Url_symbol { get; set; }

        /// <summary>
        /// Decimal precision for base currency (BTC/USD - base: BTC).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("base_decimals")]
        public int? Base_decimals { get; set; }

        /// <summary>
        /// Decimal precision for counter currency (BTC/USD - counter: USD).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("counter_decimals")]
        public int? Counter_decimals { get; set; }

        /// <summary>
        /// Decimal precision for counter currency for instant buy and cash sell orders.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("instant_order_counter_decimals")]
        public int? Instant_order_counter_decimals { get; set; }

        /// <summary>
        /// Minimum order size.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("minimum_order")]
        public string Minimum_order { get; set; }

        /// <summary>
        /// Trading engine status (Enabled/Disabled).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("trading")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TradingPairsInfoResponseSchemaTrading? Trading { get; set; }

        /// <summary>
        /// Instant and market orders status (Enabled/Disabled).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("instant_and_market_orders")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TradingPairsInfoResponseSchemaInstant_and_market_orders? Instant_and_market_orders { get; set; }

        /// <summary>
        /// Trading pair description.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TradingPairsInfoResponseSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TradingPairsInfoResponseSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Transaction
    {
        /// <summary>
        /// Number of transactions.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("count")]
        public int? Count { get; set; }

        /// <summary>
        /// Conversion order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("order_id")]
        public int? Order_id { get; set; }

        /// <summary>
        /// Trades.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("trades")]
        public System.Collections.Generic.ICollection<Trade> Trades { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static Transaction FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<Transaction>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransactionsResponse
    {
        /// <summary>
        /// Amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Unix timestamp date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("date")]
        public string Date { get; set; }

        /// <summary>
        /// Price.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("price")]
        public string Price { get; set; }

        /// <summary>
        /// Transaction ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("tid")]
        public string Tid { get; set; }

        /// <summary>
        /// 0 (buy) or 1 (sell).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TransactionsResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TransactionsResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransferToFromMainRequest
    {
        /// <summary>
        /// Amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public double Amount { get; set; }

        /// <summary>
        /// Currency.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }

        /// <summary>
        /// The Sub Account unique identifier.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("subAccount")]
        public int SubAccount { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TransferToFromMainRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TransferToFromMainRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransferToFromMainResponse
    {
        /// <summary>
        /// Additional error information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("reason")]
        public string Reason { get; set; }

        /// <summary>
        /// "ok" or "error"
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static TransferToFromMainResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<TransferToFromMainResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UserTransactionsRequest
    {
        /// <summary>
        /// Limit result to that many transactions (default: 100; maximum: 1000).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("limit")]
        public string Limit { get; set; }

        /// <summary>
        /// Skip that many transactions before returning results (default: 0, maximum: 200000). If you need to export older history contact support OR use combination of limit and since_id parameters.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("offset")]
        public string Offset { get; set; }

        /// <summary>
        /// (Optional) Show only transactions from specified transaction id. If since_id parameter is used, limit parameter is set to 1000.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("since_id")]
        public string Since_id { get; set; }

        /// <summary>
        /// (Optional) Show only transactions from unix timestamp (for max 30 days old).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("since_timestamp")]
        public string Since_timestamp { get; set; }

        /// <summary>
        /// Sorting by date and time: asc - ascending; desc - descending (default: desc).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("sort")]
        public string Sort { get; set; }

        /// <summary>
        /// Show only transactions to unix timestamp (for max 30 days old).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("until_timestamp")]
        public string Until_timestamp { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static UserTransactionsRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<UserTransactionsRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UserTransactionsResponse
    {
        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public string Datetime { get; set; }

        /// <summary>
        /// Transaction fee.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("fee")]
        public string Fee { get; set; }

        /// <summary>
        /// Transaction ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        /// <summary>
        /// Executed order ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("order_id")]
        public int? Order_id { get; set; }

        /// <summary>
        /// True if transaction is a self trade transaction.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("self_trade")]
        public bool? Self_trade { get; set; }

        /// <summary>
        /// Order ID of the complementary order of the self trade.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("self_trade_order_id")]
        public int? Self_trade_order_id { get; set; }

        /// <summary>
        /// Transaction type: 0 - deposit; 1 - withdrawal; 2 - market trade; 14 - sub account transfer; 25 - credited with staked assets; 26 - sent assets to staking; 27 - staking reward; 32 - referral reward; 35 - inter account transfer; 33 - settlement transfer; 58 - perpetual position settlement; 61 - collateral liquidation settlement.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// {currency_pair} exchange rate.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CurrencyPair")]
        public double? CurrencyPair { get; set; }

        /// <summary>
        /// {from_currency} amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("FromCurrency")]
        public string FromCurrency { get; set; }

        /// <summary>
        /// {to_currency} amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ToCurrency")]
        public string ToCurrency { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static UserTransactionsResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<UserTransactionsResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VaspSchema
    {
        /// <summary>
        /// Name of the VASP
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// VASP unique identifier
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("uuid")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Uuid { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static VaspSchema FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<VaspSchema>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WebsocketsTokenResponse
    {
        /// <summary>
        /// Token.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("token")]
        public string Token { get; set; }

        /// <summary>
        /// User ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("user_id")]
        public int? User_id { get; set; }

        /// <summary>
        /// Validity of token in seconds.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("valid_sec")]
        public int? Valid_sec { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static WebsocketsTokenResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<WebsocketsTokenResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WithdrawalRequestsRequest
    {
        /// <summary>
        /// Withdrawal request id.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Limit result to that many withdrawal requests (minimum: 1; maximum: 1000; default: 1000).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("limit")]
        public string Limit { get; set; }

        /// <summary>
        /// Skip that many withdrawal requests before returning results (minimum: 0; maximum: 200000).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("offset")]
        public string Offset { get; set; }

        /// <summary>
        /// Withdrawal requests from number of seconds ago to now (max. 50000000).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timedelta")]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        public string Timedelta { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static WithdrawalRequestsRequest FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<WithdrawalRequestsRequest>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WithdrawalRequestsResponse
    {
        /// <summary>
        /// Withdrawal address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("address")]
        public string Address { get; set; }

        /// <summary>
        /// Amount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// Currency.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// Date and time.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("datetime")]
        public System.DateTimeOffset? Datetime { get; set; }

        /// <summary>
        /// Withdrawal ID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public int? Id { get; set; }

        /// <summary>
        /// Cryptocurrency network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("network")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public WithdrawalRequestsResponseNetwork? Network { get; set; }

        /// <summary>
        /// 0 (open), 1 (in process), 2 (finished), 3 (canceled), 4 (failed) or 11 (reversed).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public int? Status { get; set; }

        /// <summary>
        /// Transaction ID (crypto withdrawals only).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("transaction_id")]
        public string Transaction_id { get; set; }

        /// <summary>
        /// Bitstamp's transaction id.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("txid")]
        public int? Txid { get; set; }

        /// <summary>
        /// 0 (SEPA), 2 (WIRE transfer), 17 (BCH), 1 (BTC), 16 (ETH), 15 (LTC), 18 (PAX), 19 (XLM), 14 (XRP), 20 (LINK), 21 (OMG), 22 (USDC), 24 (AAVE), 25 (BAT), 26 (UMA), 27 (DAI), 28 (KNC), 29 (MKR), 30 (ZRX), 31 (GUSD), 32 (ALGO), 33 (AUDIO), 34 (CRV), 35 (SNX), 36 (UNI), 38 (YFI), 39 (COMP), 40 (GRT), 42 (USDT), 43 (EURT), 46 (MATIC), 47 (SUSHI), 48 (CHZ), 49 (ENJ), 50 (HBAR), 51 (ALPHA), 52 (AXS), 53 (FTT), 54 (SAND), 55 (STORJ), 56 (ADA), 57 (FET), 58 (RGT), 59 (SKL), 60 (CEL), 61 (SLP), 62 (SXP), 65 (DYDX), 66 (FTM), 67 (SHIB), 69 (AMP), 71 (GALA), 72 (PERP).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public int? Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static WithdrawalRequestsResponse FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<WithdrawalRequestsResponse>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Step
    {

        _60 = 60,

        _180 = 180,

        _300 = 300,

        _900 = 900,

        _1800 = 1800,

        _3600 = 3600,

        _7200 = 7200,

        _14400 = 14400,

        _21600 = 21600,

        _43200 = 43200,

        _86400 = 86400,

        _259200 = 259200,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Time
    {

        [System.Runtime.Serialization.EnumMember(Value = @"day")]
        Day = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"hour")]
        Hour = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"minute")]
        Minute = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response
    {

        [System.Text.Json.Serialization.JsonPropertyName("data")]
        public OHLCDataResponseSchema Data { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static Response FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<Response>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response2
    {

        [System.Text.Json.Serialization.JsonPropertyName("data")]
        public System.Collections.Generic.ICollection<VaspSchema> Data { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("pagination")]
        public PaginationSchema Pagination { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Serialize(this, options);

        }
        public static Response2 FromJson(string data)
        {

            var options = new System.Text.Json.JsonSerializerOptions();

            return System.Text.Json.JsonSerializer.Deserialize<Response2>(data, options);

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CryptoTransactionNetwork
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin-cash")]
        BitcoinCash = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin")]
        Bitcoin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"litecoin")]
        Litecoin = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"xrpl")]
        Xrpl = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"algorand")]
        Algorand = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"flare")]
        Flare = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"hedera")]
        Hedera = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"cardano")]
        Cardano = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"songbird")]
        Songbird = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"avalanche-c-chain")]
        AvalancheCChain = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"solana")]
        Solana = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"polkadot")]
        Polkadot = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"near")]
        Near = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"doge")]
        Doge = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"sui")]
        Sui = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"casper")]
        Casper = 17,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CryptoWithdrawalRequestNetwork
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin-cash")]
        BitcoinCash = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin")]
        Bitcoin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"litecoin")]
        Litecoin = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"xrpl")]
        Xrpl = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"algorand")]
        Algorand = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"flare")]
        Flare = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"hedera")]
        Hedera = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"cardano")]
        Cardano = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"songbird")]
        Songbird = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"avalanche-c-chain")]
        AvalancheCChain = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"solana")]
        Solana = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"polkadot")]
        Polkadot = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"near")]
        Near = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"doge")]
        Doge = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"sui")]
        Sui = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"casper")]
        Casper = 17,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CurrencySchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"crypto")]
        Crypto = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"fiat")]
        Fiat = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DepositAddressRequestNetwork
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin-cash")]
        BitcoinCash = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin")]
        Bitcoin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"litecoin")]
        Litecoin = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"xrpl")]
        Xrpl = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"algorand")]
        Algorand = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"flare")]
        Flare = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"hedera")]
        Hedera = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"cardano")]
        Cardano = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"songbird")]
        Songbird = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"avalanche-c-chain")]
        AvalancheCChain = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"solana")]
        Solana = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"polkadot")]
        Polkadot = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"near")]
        Near = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"doge")]
        Doge = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"sui")]
        Sui = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"casper")]
        Casper = 17,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionSchemaEarn_term
    {

        [System.Runtime.Serialization.EnumMember(Value = @"FLEXIBLE")]
        FLEXIBLE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FIXED")]
        FIXED = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionSchemaEarn_type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"STAKING")]
        STAKING = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LENDING")]
        LENDING = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionSettingSchemaEarn_type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"STAKING")]
        STAKING = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LENDING")]
        LENDING = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionSettingSchemaSetting
    {

        [System.Runtime.Serialization.EnumMember(Value = @"OPT_IN")]
        OPT_IN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"OPT_OUT")]
        OPT_OUT = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionsSchemaDistribution_period
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DAILY")]
        DAILY = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"WEEKLY")]
        WEEKLY = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"MONTHLY")]
        MONTHLY = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"QUARTERLY")]
        QUARTERLY = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionsSchemaTerm
    {

        [System.Runtime.Serialization.EnumMember(Value = @"FLEXIBLE")]
        FLEXIBLE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FIXED")]
        FIXED = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnSubscriptionsSchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"STAKING")]
        STAKING = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LENDING")]
        LENDING = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnTransactionSchemaStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"COMPLETED")]
        COMPLETED = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CANCELED")]
        CANCELED = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EarnTransactionSchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"STAKE")]
        STAKE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"UNSTAKE")]
        UNSTAKE = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"REWARD_RECEIVED")]
        REWARD_RECEIVED = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"OPT_IN")]
        OPT_IN = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"OPT_OUT")]
        OPT_OUT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"SUBSCRIBE")]
        SUBSCRIBE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"UNSUBSCRIBE")]
        UNSUBSCRIBE = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FeeWithdrawalRequestNetwork
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin-cash")]
        BitcoinCash = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin")]
        Bitcoin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"litecoin")]
        Litecoin = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"xrpl")]
        Xrpl = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"algorand")]
        Algorand = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"flare")]
        Flare = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"hedera")]
        Hedera = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"cardano")]
        Cardano = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"songbird")]
        Songbird = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"avalanche-c-chain")]
        AvalancheCChain = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"solana")]
        Solana = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"polkadot")]
        Polkadot = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"near")]
        Near = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"doge")]
        Doge = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"sui")]
        Sui = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"casper")]
        Casper = 17,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FeeWithdrawalResponseNetwork
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin-cash")]
        BitcoinCash = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin")]
        Bitcoin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"litecoin")]
        Litecoin = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"xrpl")]
        Xrpl = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"algorand")]
        Algorand = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"flare")]
        Flare = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"hedera")]
        Hedera = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"cardano")]
        Cardano = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"songbird")]
        Songbird = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"avalanche-c-chain")]
        AvalancheCChain = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"solana")]
        Solana = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"polkadot")]
        Polkadot = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"near")]
        Near = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"doge")]
        Doge = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"sui")]
        Sui = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"casper")]
        Casper = 17,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TradingPairsInfoResponseSchemaTrading
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Enabled")]
        Enabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TradingPairsInfoResponseSchemaInstant_and_market_orders
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Enabled")]
        Enabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum WithdrawalRequestsResponseNetwork
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin-cash")]
        BitcoinCash = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"bitcoin")]
        Bitcoin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ethereum")]
        Ethereum = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"litecoin")]
        Litecoin = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stellar")]
        Stellar = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"xrpl")]
        Xrpl = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"algorand")]
        Algorand = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"flare")]
        Flare = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"hedera")]
        Hedera = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"cardano")]
        Cardano = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"songbird")]
        Songbird = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"avalanche-c-chain")]
        AvalancheCChain = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"solana")]
        Solana = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"polkadot")]
        Polkadot = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"near")]
        Near = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"doge")]
        Doge = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"sui")]
        Sui = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"casper")]
        Casper = 17,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    internal class DateFormatConverter : System.Text.Json.Serialization.JsonConverter<System.DateTimeOffset>
    {
        public override System.DateTimeOffset Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
        {
            var dateTime = reader.GetString();
            if (dateTime == null)
            {
                throw new System.Text.Json.JsonException("Unexpected JsonTokenType.Null");
            }

            return System.DateTimeOffset.Parse(dateTime);
        }

        public override void Write(System.Text.Json.Utf8JsonWriter writer, System.DateTimeOffset value, System.Text.Json.JsonSerializerOptions options)
        {
            writer.WriteStringValue(value.ToString("yyyy-MM-dd"));
        }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625